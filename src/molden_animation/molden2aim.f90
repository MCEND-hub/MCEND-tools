!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Molden2AIM: a utility to convert the format from MOLDEN to AIM-WFN, AIM-WFX, and NBO-47.
!
! Webpage: https://github.com/zorkzou/Molden2AIM
!
! E-mail: qcband@gmail.com
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
program Molden2AIM
 implicit real(kind=8) (a-h,o-z)

! MOLDEN files generated by the following programs require special modifications
 parameter(nprog=9)
 character*20      :: pname(nprog)
!               1       2           3        4       5        6      7      8      9
 data pname/'ORCA','CFOUR','TURBOMOLE','JAGUAR','ACES2','MOLCAS','PSI4','MRCC','NBO6'/

! Cartesian NC-/C-GTO; Spherical NC-/C-GTO
 dimension         :: ncar(2),nsph(2)

 dimension         :: ICntrl(8)
 logical           :: doit,ifopen,ifwbo

 character*57      :: fwfn,fwfx,fnbo
 character*64      :: fmdn
 character*10      :: dt
 character*5       :: ver
 character*1       :: yn,L2U
 character*100     :: stline

!=================================================================================================================================
!  head
!=================================================================================================================================
 ver = "4.2.1"
 dt  = "05/11/2018"
 call headprt(ver,dt)

!=================================================================================================================================
!  Initialization
!=================================================================================================================================
 ICntrl(1)=1         ! Generating a standard Molden file in Cartesian functions
 ICntrl(2)=1         ! Generating a WFN file
 ICntrl(3)=0         ! Generating a WFX file
 ICntrl(4)=0         ! Generating a NBO .47 file
 ICntrl(5)=0         ! Checking normalization for WFN
 ICntrl(6)=0         ! Checking normalization for WFX
 ICntrl(7)=0         ! Checking normalization for NBO's .47
 ICntrl(8)=0         ! Calculate Generalized Wiberg bond order when ICntrl(4) >= 0
                     !
                     ! >0:  always performs the operation without asking the user
                     ! =0:  asks the user whether to perform the operation
                     ! <0:  always neglect the operation without asking the user

 IAllMO=0            ! WFN and WFX
                     ! =0: print only the orbitals with occ. number > 5.0d-8
                     ! <0: print only the orbitals with occ. number > 0.1 (debug)
                     ! >0: print all the orbitals

 ICln=1              ! delete temporary files (1) or not (0)

 iprog=0             ! 1: ORCA, 2: CFOUR, 3: TURBOMOLE, 4: JAGUAR, ...
                     ! 0: other programs, or read [Program] xxx from MOLDEN.
                     ! If one of the above program is always used, you can provide iprog here without defining
                     ! [Program] xxx in MOLDEN any more.

 nosupp=0            ! Print supporting information (0) or not ( /= 0)

 irdecp=0            ! For ECP: read core information from Molden file
                     ! <=0: if total_occupation_number is smaller than the total_Za, ask the user whether to read core information
                     !  >0: always search and read core information

!=================================================================================================================================
! Port numbers. Do not modify them.
!
! Port numbers 4x: important input and output files
! Port numbers 6x: temporary files used in sub. backupgto
! Port numbers 7x: temporary files
!=================================================================================================================================
 iini=40             ! m2a.ini
 imod=44             ! original molden file
 inmd=45             ! new molden file in Cartesian functions
 iwfn=46             ! wfn file
 iwfx=47             ! wfx file
 inbo=48             ! NBO 47 file
 iwbo=49             ! Generalized Wiberg bond order

 itmp=65             ! see backupgto
 igin=66             ! see backupgto
 igol=67             ! see backupgto
 iatm=70             ! coordinates
 igto=71             ! basis functions
 imol=72             ! MO data of Cartesian functions
 ispn=73             ! MO spin, occupation, and energy
 imo0=74             ! raw MO data; the missing zeros will be filled in
 icor=75             ! CORE data
 iedf=76             ! EDF data for ECP

! The following integers will be determined later. Do not modify them here.
 ifc4=1              ! a scaling factor for occ. numbers: x 1 (1) or x 2 (2)
 iecp=0              ! PP (ECP or MCP) is used (> 0; = #core_electron) or not (0)
 lsph=0              ! MOs are in Cartesian (0) or spherical (1) basis functions

!=================================================================================================================================
!  read user's parameters from m2a.ini
!=================================================================================================================================
 call uinit(iini,nprog,ICntrl,ICln,IAllMO,iprog,nosupp,irdecp,iunknw,stline)

!=================================================================================================================================
!  program list which can save MOLDEN file
!=================================================================================================================================
 if(nosupp == 0) call SuppInf

!=================================================================================================================================
!  define file names
!=================================================================================================================================
 call filename(imod,fmdn,fwfn,fwfx,fnbo)

 open(iatm,file='atm123456789.tmp')
 open(igto,file='gto123456789.tmp')
 open(imol,file='mol123456789.tmp')
 open(ispn,file='spn123456789.tmp')
 open(imo0,file='mo0123456789.tmp')
 open(icor,file='cor123456789.tmp')
 open(iedf,file='edf123456789.tmp')

!=================================================================================================================================
!  search [Program] and get the name of the program.
!  [Program] is a special keyword for Molden2AIM.
!  iprog = 0 (default), 1 (orca), 2 (cfour), 3 (turbomole), ...
!=================================================================================================================================
 call getprog(imod,nprog,pname,iprog,stline)

!=================================================================================================================================
!  backup molden file and delete some redundant (e.g. Pople GTO by ACES2) or not useful data (e.g. unoccupied MOs)
!=================================================================================================================================
 call backupatm(imod,iatm,ifind,stline)
 if(ifind == 0)goto 9910           ! STOP: [ATOMS] was not found
 call natom(iatm,nat,nchar,iunit,ierr)  ! iunit = 0: Ang. 1: Bohr 2: Error
 if(ierr /= 0)goto 9910            ! STOP: deMon2k's geometry optimization, or wrong ordering
 call backupgto(imod,igto,itmp,igin,igol,nat,iprog,ifind,stline)
 if(ifind == 0)goto 9910           ! STOP: [GTO] was not found, or wrong ordering
 call npgau(igto,Ierr,ncar,nsph,MaxL,stline)   ! # of uc. and c. GTO
 if(Ierr == 1)then
!  For CFour, there may be basis functions higher than g
   write(*,*)"Error! Only S,P,D,F,G functions are supported!"
   write(*,*)"Please check your MOLDEN file."
   goto 9910
 else if(Ierr == 2)then
!  ncar(1) > maxpg or ncar(2) > maxpgc
   goto 9910
 end if
! check: Car. vs Sph.
 call checkcar2(ncarmo,ishrt,ifind,stline)
 if(ifind == 0)goto 9910           ! STOP: [MO] cannot be found
 if(iprog == 4)then
   ncarmo=ncar(2)
   ishrt=1
   lsph=0
   write(*,"(' >>> Cartesian basis functions are used by Jaguar.',/)")
 else
   if(ncarmo == ncar(2))then
     write(*,"(' >>> Cartesian basis functions are used.',/)")
     lsph=0
   else if(ncarmo < ncar(2) .and. ncarmo == nsph(2))then
     write(*,"(' >>> Spherical basis functions are used.',/)")
     lsph=1
!    molcas with spherical functions: do nothing
     if(iprog == 6) iprog=-6
!    mrcc with spherical functions: do nothing
     if(iprog == 8) iprog=-8
   else if(ncarmo < ncar(2) .and. ncarmo > nsph(2))then
     write(*,"(' Wrong! NCARMO=',i5,', NCGTO=',i5,/,' Sperical and Cartesian functions are mixed together.',/,  &
       ' This is not supported.')") ncarmo,ncar(2)
     goto 9910
   else
     write(*,"(' Wrong! NCARMO=',i5,', NCGTO=',i5,/)") ncarmo,ncar(2)
     goto 9910
   end if
 end if
! compute scaling factors of MO
 call moscale(igto,iprog,ncar(2))

!=================================================================================================================================
!  backup MO
!=================================================================================================================================
 call fill0s(imo0,ncarmo,ishrt,stline)
 if(IAllMO == 0)then
   tolocc=5.0d-8
 else if(IAllMO > 0)then
   tolocc=-1.0d2
 else
   tolocc=1.0d-1 - 5.0d-8
 end if
 if(lsph == 0)then
   call backupmolc(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,ncar(2),tolocc,stline,ierr)
 else
   call backupmols(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,iprog,tolocc,stline,ierr)
 end if
 if(ierr /= 0)then
   write(*,"(/,' Wrong! Star (*) is found in MO coefficients.',/,           &
     ' If the occupation is weak, please delete this MO and run again,',/,  &
     ' otherwise you have to calculate the MO coefficient.')")
   goto 9910
 end if

 write(*,"(' >>> SUMMARY',//,                               &
   5x,'Number of atoms: ',25x,i8,/,                         &
   5x,'Maximum angular momentum: ',16x,i8,/,                &
   5x,'Number of primitive Cartesian functions: ',1x,i8,/,  &
   5x,'Number of contracted Cartesian functions: ',i8,/,    &
   5x,'Number of primitive spherical functions: ',1x,i8,/,  &
   5x,'Number of contracted spherical functions: ',i8,/,    &
   5x,'Number of orbitals to be printed: ',8x,i8)") nat,MaxL,ncar(1),ncar(2),nsph(1),nsph(2),nmo

! check
 if(iprog /= 0)then
   call chkbstyp(lsph,iprog,MaxL,ierr)
   if(ierr /= 0) goto 9910
 end if
 if(nmo < 1)then
   write(*,*)"Error! No occupied MOs are found!"
   write(*,*)
!  There is a bug in Dalton2013, which may have been solve now.
   if(iprog == 0) write(*,*) "If you are using Dalton, try the latest version."
!  In old version of MRCC, occ=0 if occupations are specified
   if(abs(iprog) == 8) write(*,*) "Try the latest version of MRCC."
   goto 9910
 end if
 if(ncar(1) < 1)then
   write(*,*)"Error! No Primitive Basis Functions are found!"
   write(*,*)
   write(*,*)"Please check your MOLDEN file."
   goto 9910
 end if
 if(nat < 1)then
   write(*,*)"Error! No atoms are found!"
   write(*,*)
   write(*,*)"Please check your MOLDEN file."
   goto 9910
 end if
 if(iunit /= 1 .and. iunit /= 0)then
   write(*,*)"Error! The unit of the coordinates is not defined!"
   write(*,*)
   write(*,*)"Please check your MOLDEN file."
   goto 9910
 end if

!=================================================================================================================================
!  read core data
!=================================================================================================================================
 chanet = 0.d0

 if(abs(dble(nchar)-sumocc) > 0.001d0 .and. irdecp <= 0)then
!  write(*,"(//,' Is ECP or MCP used? ([Yes] / No)',/,' > ',$)")
!  read(*,"(a1)")yn
   yn='No'
   yn=L2U(yn)
   if(yn /= 'N') irdecp = 1
 end if
 if(irdecp > 0)then
   call RdCore(iatm,imod,icor,nat,iecp,ierr,stline)
   if(ierr /= 0)goto 9910
 end if

 if(abs(dble(nchar-iecp)-sumocc) > 0.001d0)then
   call chkcharge(nchar,sumocc,iprog,ifc4,iecp,chanet,ierr)
   if(ierr /= 0)goto 9910
 end if
!total number of electrons: core electrons by ECP should be excluded!
 ntote = nchar - iecp - nint(chanet)
 write(*,8000)

!=================================================================================================================================
!  write a standard Molden file in Cartesian basis functions
!=================================================================================================================================
 if(ICntrl(1) > 0)then
   doit = .true.
 else if(ICntrl(1) == 0)then
   write(*,"(////,' Do you want to generate a new Molden file? ([Yes] / No)',/,' > ',$)")
   read(*,"(a1)")yn
   yn=L2U(yn)
   if(yn == 'N')then
     doit = .false.
   else
     doit = .true.
   end if
 else
   doit = .false.
 end if

 if(doit) then
   call genmdn(fmdn,inmd,iatm,igto,imol,imo0,icor,ver,dt,nat,nmotot,ncarmo,ncar(2),ifc4,iecp,stline)
   write(*,8000)
 end if

!=================================================================================================================================
!  write *.wfn
!=================================================================================================================================
 if(ICntrl(2) > 0)then
   doit = .true.
 else if(ICntrl(2) == 0)then
   write(*,"(////,' Do you want to generate a *.WFN file? ([Yes] / No)',/,' > ',$)")
   read(*,"(a1)")yn
   yn=L2U(yn)
   if(yn == 'N')then
     doit = .false.
   else
     doit = .true.
   end if
 else
   doit = .false.
 end if

 if(doit) then
   call writitle(iwfn,fwfn,ver,dt)

   write(iwfn,"('GAUSSIAN',8x,i7,' MOL ORBITALS',i7,' PRIMITIVES',i9,' NUCLEI')")nmo, ncar(1), nat

   call writeatm(iwfn,iatm,icor,nat,iecp)
   call writecnt(iwfn,0,igto,imol,ncar(1))
   call writemol(iwfn,imol,nmotot,ncar(1),ncar(2),tolocc,ifc4,stline)   ! ifc4=1 or 2 (CFour,Q-chem)
   write(iwfn,"('END DATA')")
   write(iwfn,"(' THE  HF ENERGY =',f20.12,' THE VIRIAL(-V/T)=',f13.8)")0.d0,2.d0

!  Spin of MO. These data can be used by MultiWFN.
!  if ifspin=0, "Spin" cannot be found in Molden
   if(ifspin == 1) call writespn(iwfn,ispn,ifbeta,nmo)

!  final step
   call finalwfn(fwfn,iecp,MaxL)
!IU: abort here
   goto 9910

!  Check the AIM-WFN file
   if(ICntrl(5) > 0)then
     doit = .true.
   else if(ICntrl(5) == 0)then
     write(*,"(/,' Do you want to check the *.WFN file? ([Yes] / No)')")
!    WFN with ECP is supported only by MultiWFN at present
     if(iecp == 0) write(*,"(' (Omit it if you are using AIMALL because AIMALL will do it much faster.)')")
     write(*,"(' > ',$)")
     read(*,"(a1)")yn
     yn=L2U(yn)
     if(yn == 'N')then
       doit = .false.
     else
       doit = .true.
     end if
   else
     doit = .false.
   end if

   if(doit) then
     call CheckWFN(iwfn,nat,ncar(1),MaxL,info)
     if(info /= 0) goto 9910
   end if
   write(*,8000)
 end if

!=================================================================================================================================
!  write *.wfx
!=================================================================================================================================
 if(ICntrl(3) > 0)then
   doit = .true.
 else if(ICntrl(3) == 0)then
   write(*,"(////,' Do you want to generate a *.WFX file? ([Yes] / No)',/,' > ',$)")
   read(*,"(a1)")yn
   yn=L2U(yn)
   if(yn == 'N')then
     doit = .false.
   else
     doit = .true.
   end if
 else
   doit = .false.
 end if

 if(doit) then

   call edfmain(icor,iedf,iecp,nat,nedf)

   call genwfx(iatm,igto,imol,ispn,icor,iedf,iwfx,fwfx,ver,dt,nat,nmotot,nmo,chanet,tolocc,ntote,ncar(1),ncar(2),nedf,iecp,  &
     ifc4,ifspin,ifbeta,iunknw,stline)

!  final step
   call finalwfx(fwfx,iecp,iunknw,MaxL)

!  Check the AIM-WFX file
   if(ICntrl(6) > 0)then
     doit = .true.
   else if(ICntrl(6) == 0)then
     write(*,"(/,' Do you want to check the *.WFX file? ([Yes] / No)',/,  &
       ' (Omit it if you are using AIMALL because AIMALL will do it much faster.)',/,' > ',$)")
     read(*,"(a1)")yn
     yn=L2U(yn)
     if(yn == 'N')then
       doit = .false.
     else
       doit = .true.
     end if
   else
     doit = .false.
   end if

   if(doit) then
     call CheckWFX(iwfx,nat,ncar(1),MaxL,info,stline)
     if(info /= 0) goto 9910
   end if

   write(*,8000)
 end if

!=================================================================================================================================
!  write NBO *.47
!=================================================================================================================================
 if(ICntrl(4) > 0)then
   doit = .true.
 else if(ICntrl(4) == 0)then
   write(*,"(////,' Do you want to generate NBO *.47 file? ([Yes] / No)',/,' > ',$)")
   read(*,"(a1)")yn
   yn=L2U(yn)
   if(yn == 'N')then
     doit = .false.
   else
     doit = .true.
   end if
 else
   doit = .false.
 end if

 if(doit) then
   OPEN(inbo,FILE=fnbo)

!  Generalized Wiberg bond order?
   if(ICntrl(8) > 0)then
     doit = .true.
   else if(ICntrl(8) == 0)then
     write(*,"(/,' Do you want to calculate Wiberg bond order? ([Yes] / No)')")
     write(*,"(' > ',$)")
     read(*,"(a1)")yn
     yn=L2U(yn)
     if(yn == 'N')then
       doit = .false.
     else
       doit = .true.
     end if
   else
     doit = .false.
   end if
   ifwbo = doit
   if(doit) then
     lenth=Len_trim(fnbo)-3
     OPEN(iwbo,FILE=(fnbo(1:lenth)//'_wbo.out'))
   end if

   call cbsinf(igto,nat,nshell,nexp)
   call gennbo(inbo,iwbo,iatm,igto,imol,icor,ver,dt,nat,nshell,nexp,ncar(2),nmotot,MaxL,ifc4,iecp,ifwbo,info,stline)
   if(info /= 0) goto 9910

!  final step
   call finalnbo(fnbo,MaxL)

!  Check the NBO .47 file
   if(ICntrl(7) > 0)then
     doit = .true.
   else if(ICntrl(7) == 0)then
     write(*,"(/,' Do you want to check the *.47 file? ([Yes] / No)')")
     write(*,"(' > ',$)")
     read(*,"(a1)")yn
     yn=L2U(yn)
     if(yn == 'N')then
       doit = .false.
     else
       doit = .true.
     end if
   else
     doit = .false.
   end if

   if(doit) then
     call CheckNBO(inbo,nat,ncar(2),sumocc*dble(ifc4),info,stline)
     if(info /= 0) goto 9910
   end if
   write(*,8000)
 end if

!=================================================================================================================================
 9910  continue
 inquire(unit=iini,opened=ifopen)
 if(ifopen) close(iini)
 close(imod)
 inquire(unit=inmd,opened=ifopen)
 if(ifopen) close(inmd)
 inquire(unit=iwfn,opened=ifopen)
 if(ifopen) close(iwfn)
 inquire(unit=iwfx,opened=ifopen)
 if(ifopen) close(iwfx)
 inquire(unit=inbo,opened=ifopen)
 if(ifopen) close(inbo)
 inquire(unit=iwbo,opened=ifopen)
 if(ifopen) close(iwbo)
 if(ICln == 0)then
   close(iatm)
   close(igto)
   close(imol)
   close(ispn)
   close(imo0)
   close(icor)
   close(iedf)
 else
   close(iatm,status='delete')
   close(igto,status='delete')
   close(imol,status='delete')
   close(ispn,status='delete')
   close(imo0,status='delete')
   close(icor,status='delete')
   close(iedf,status='delete')
 end if

!call estop

 8000  format(1x,77('='))
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write MO.s to the *.wfn file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine writemol(iwfn,imol,nmo,ng,ngc,tolocc,ifc4,tmp)
 implicit real(kind=8) (a-h,o-z)
 parameter(maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 character*100     :: tmp

! normalization factor
 do i=1,ng
   cn(i)=fnorm_lmn(expg(i),ityp(i))
 end do

 rewind(imol)
 do i=1,nmo
!  in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
   occ=0.d0
   ene=0.d0
   read(imol,"(a100)") tmp
   is=index(tmp,'=')
   if(index(tmp(is+1:),'***') == 0) read(tmp(is+1:),*) occ
   read(imol,"(a100)") tmp
   is=index(tmp,'=')
   if(index(tmp(is+1:),'***') == 0) then
     read(tmp(is+1:),*) ene
     ene = sign(min(abs(ene), 1.d6), ene)
   end if
   do j=1,ngc
     read(imol,*)ingc,cfmo(j)
     cfmo(j)=cfmo(j)*scalmo(j)
   end do
   if(abs(occ) >= tolocc)then
     if(abs(eng) < 9999.d0)then
       write(iwfn,1000)i,occ*dble(ifc4),eng
     else
       write(iwfn,1100)i,occ*dble(ifc4),eng
     end if
!    N*cgto*cmo
     write(iwfn,"(5d16.8)")(cn(j)*conf(j)*cfmo(icmo(j)),j=1,ng)
   end if
 end do

 return
 1000  format("MO",i5,5x,"MO 0.0",8x,"OCC NO =",f13.7,"  ORB. ENERGY =",f12.6)
 1100  format("MO",i5,5x,"MO 0.0",8x,"OCC NO =",f13.7,"  ORB. ENERGY =",f12.4)
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Read user's initialization parameters from m2a.ini
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine uinit(iini,nprog,ICntrl,ICln,IAllMO,iprog,nosupp,irdecp,iunknw,ctmp)
 implicit real(kind=8) (a-h,o-z)
 parameter(nkey=14)
 Dimension         :: ICntrl(8)
 character*100     :: ctmp
 character*9       :: keyword(nkey)
 data keyword/"MOLDEN=","WFN=","WFX=","NBO=","WFNCHECK=","WFXCHECK=","NBOCHECK=","WBO=","PROGRAM=","CLEAR=","IALLMO=",  &
   "NOSUPP=","RDCORE=","UNKNOWN="/

 open(iini,file='m2a.ini',status='old',err=9000)
 rewind(iini)

 do while(.true.)
   read(iini,"(a100)",end=9000)ctmp

   if(ctmp(1:1) == "$" .or. ctmp(1:1) == "%" .or. ctmp(1:1) == "!" .or. len_trim(ctmp) == 0) cycle

   call charl2u(ctmp)
   ikey=0
   do i=1,nkey
     if(index(ctmp,trim(keyword(i))) /= 0) then
       ikey=i
       istart=index(ctmp,"=")+1
       read(ctmp(istart:100),*)keyvalue
       exit
     end if
   end do

   if(ikey == 0) cycle

   select case(ikey)
     case(1:8)
       if(keyvalue > 0) then
         keyvalue=1
       else if(keyvalue < 0) then
         keyvalue=-1
       end if
       ICntrl(ikey)=keyvalue
     case(9)
       if(keyvalue < 0 .or. keyvalue > nprog) keyvalue=0
       iprog=keyvalue
     case(10)
       if(keyvalue /= 0) keyvalue=1
       ICln=keyvalue
     case(11)
       if(keyvalue > 0)then
         keyvalue=1
       else if(keyvalue < 0)then
         keyvalue=-1
       end if
       IAllMO=keyvalue
     case(12)
       nosupp = 0
       if(keyvalue /= 0) nosupp = 1
     case(13)
       irdecp = 0
       if(keyvalue /= 0) irdecp = 1
     case(14)
       iunknw = 0
       if(keyvalue /= 0) iunknw = 1
   end select
 end do
 close(iini)

 9000  return
End

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! generate NBO's *.47 data file (always in Cartesian functions).
!
!     Paremeters
!     inbo,iatm,igto : ports
!     ver,dt         : version number and date
!     natm           : # atoms
!     nshell         : # contracted shells
!     nexp           : # primitive exponents
!     nbas           : # contracted Cartesian basis functions
!     MaxL           : max L (<=4 at present)
!
! NOTE:
!
! 1) It requires overlap and density in contracted Cartesian functions.
!
! 2) Fock matrix is not available, so the 2'nd order of perturbation cannot be calculated.
!
! 3) T and V: optional and not calculated here. They are not defined in the case of all-electron scalar relativistic calculation.
!
! 4) $LCAOMO requires both occupied and unoccupied MOs, and #MO = #BAS. However this may be not true since Cartesian basis
!    functions are always used here. Because of this reason, $LCAOMO is ignored at present.
!
! 5) If ECP is used, you have to correct iz(2) in $COORD by hand.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine gennbo(inbo,iwbo,iatm,igto,imol,icor,ver,dt,natm,nshell,nexp,nbas,nmo,MaxL,ifc4,iecp,ifwbo,info,ctmp)
 implicit real(kind=8) (a-h,o-z)
 parameter(au2ang=0.529177249d0,maxpg=14000,maxpgc=10000)
! scalmo will be used
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 logical           :: ifwbo
 character*4       :: cnatm
 character*5       :: cnbas, ver
 character*10      :: dt
 character*100     :: ctmp
 dimension         :: xyz(3,natm),ncomp(nshell),nprim(nshell),nptr(nshell),ncshl(nshell),expn(nexp),con(nexp),nc(nbas),label(nbas)
 allocatable       :: scr1(:),scr2(:),scr3(:)

 lsph=0    ! always in Cartesian functions
 ntt=nbas*(nbas+1)/2
 nss=max(225,nbas*nbas)    ! 225 is required in OvDriv2
 allocate(scr1(ntt),scr2(ntt),scr3(nss))

 ncore = 0
 rewind(icor)

 rewind(inbo)

 write(cnatm,"(i4)")natm
 cnatm=ADJUSTL(cnatm)
 write(cnbas,"(i5)")nbas
 cnbas=ADJUSTL(cnbas)

! gennbo: $GENNBO
 write(inbo,"(' $GENNBO  NATOMS=',a4,' NBAS=',a5,' UPPER  BODM  $END')")cnatm,cnbas

! gennbo: $NBO
 write(inbo,"(' $NBO BNDIDX NLMO $END')")

! gennbo: $COORD
 write(inbo,"(' $COORD')")
! if fdate doesn't work, just use this line
! write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
 call fdate(ctmp)
 call trulen(ctmp,L1,L2,length)
 write(inbo,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,'Time: ',a24)")ver,dt,ctmp(L1:L2)

 rewind(iatm)
 read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
 fc=1.d0
 if(iu /= 0)fc=au2ang
 do i=1,natm
   read(iatm,*)ctmp,ia,iz,xyz(1,i),xyz(2,i),xyz(3,i)
   call ascale(3,fc,xyz(1,i),xyz(1,i))
   if(iecp > 0) read(icor,*) j, ncore
!  About NBO6:
!  1. It may lead to numerical errors of about 1.0d-6 in the overlap matrix, which cannot pass the examination of NBO6. More
!     digits should be printed.
!  2. au2ang: in NBO3, 0.529177249 is used instead of 0.529177. This may be also true in NBO6.
   write(inbo,"(1x,2i5,3f18.9)")iz,iz-ncore,(xyz(j,i),j=1,3)
 end do
 write(inbo,"(' $END')")
! xyz: Ang. --> Bohr
 call ascale(3*natm,(1.d0/au2ang),xyz,xyz)

! read contracted basis functions from igto
 call RdConBF(igto,natm,nshell,nexp,nbas,lsph,ncomp,nprim,nptr,ncshl,expn,con,nc,label)

! gennbo: $BASIS
 call wrbas(inbo,nbas,nc,label)

! gennbo: $CONTRACT
 call wrctr(inbo,nshell,nexp,MaxL,lsph,ncomp,nprim,nptr,expn,con,scr1)

! gennbo: $OVERLAP
 write(*,"(/,'  Calculating overlap matrix...')")
 call OvDriv2(inbo,nshell,nexp,nbas,MaxL,lsph,xyz,ncomp,nprim,nptr,ncshl,expn,con,scr1,scr3,info)
   if(info /= 0) return

! gennbo: $DENSITY
 write(*,"('  Calculating density matrix...')")
 call DenDriv(inbo,imol,nbas,nmo,dble(ifc4),scalmo,scr2,scr3)

! Generalized Wiberg bond order
!   1. natm <= nbas is required, which should be true.
!   2. S (in scr1) and P (in scr2) will be destroyed.
 if(ifwbo) then
   write(*,"('  Calculating GWBO...')")
   call GWBO(iwbo,nbas,natm,nc,scr1,scr2,scr3,scr1)
 end if

 deallocate(scr1,scr2,scr3)

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Generalized Wiberg bond order index, which is Mayer's bond order in the case of closed-shell system.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine GWBO(iwbo,N,Natm,icent,S,P,D,bo)
 implicit real(kind=8) (a-h,o-z)
 parameter(NCol=10)
 dimension         :: icent(*),S(*),P(*),D(N,N),bo(Natm,Natm)

! D = P * S
 call AClear(N*N,D)
 call LTxLT(N,P,S,D)

! D = D .* D^T
 do i = 1, N
   do j = 1, i-1
     D(j,i) = D(i,j) * D(j,i)
!    D(i,j) = D(j,i)    ! not used
   end do
 end do

 call AClear(Natm*Natm,bo)
 do i = 1, N
   ii = icent(i)
   do j = 1, i-1
     jj = icent(j)
     if(ii /= jj)then
       bo(jj,ii) = bo(jj,ii) + D(j,i)
!      bo(ii,jj) = bo(jj,ii)    ! not used
       bo(ii,ii) = bo(ii,ii) + D(j,i)
       bo(jj,jj) = bo(jj,jj) + D(j,i)
     end if
   end do
 end do

 rewind(iwbo)
 write(iwbo,1010)

 NBlock=(Natm-1)/NCol+1
 do i=1,NBlock
   iv1=(i-1)*NCol+1
   iv2=min(i*NCol,Natm)
   write(iwbo,1020)(k,k=iv1,iv2)
   write(iwbo,*)
   do j=iv1,Natm
     write(iwbo,1030)j,(bo(k,j),k=iv1,min(iv2,j))
   end do
 end do

 return
 1010  format(' Generalized Wiberg bond order indices in MO.',//,'   E(i,i) = Total WBO of atom i, and',/,  &
         '   E(i,j) = WBO between atoms i and j.',/)
 1020  format(/,' I_atm        ',10i8)
 1030  format(i6,8x,10f8.4)
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! driver of density matrix calculation
!
!   nbas   : # contracted Cartesian functions
!   nmo    : # MO
!   focc   : a pre-factor of occupation number (1.0 or 2.0)
!   scalmo : scaling factors of MO coefficients
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine DenDriv(inbo,imol,nbas,nmo,focc,scalmo,Den,cmo)
 implicit real(kind=8) (a-h,o-z)
 parameter(occtol=1.d-8)
 dimension         :: scalmo(*),Den(*),cmo(*)

 NTTS=nbas*(nbas+1)/2
 call AClear(NTTS,Den)

 rewind(imol)
 do i=1,nmo
!  read occ. number & MO coefficients from imol (in Cartesian b.s.)
   read(imol,"(7x,f20.8)")occ
   read(imol,*)
   occ=focc*occ
   do ibs=1,nbas
     read(imol,*)idx,cmo(ibs)
     cmo(ibs)=cmo(ibs)*scalmo(ibs)
   end do
   if(abs(occ) < occtol) cycle

!  density matrix
   j=0
   do ibs=1,nbas
     do jbs=1,ibs
       j=j+1
       Den(j)=Den(j)+occ*cmo(ibs)*cmo(jbs)
     end do
   end do

 end do

 call noiserm(Den,NTTS)
 write(inbo,"(' $DENSITY')")
 write(inbo,"(2x,5e15.7e2)")(Den(i),i=1,NTTS)
 write(inbo,"(' $END')")

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read core information from the [CORE] or [PSEUDO] block specified by the user
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine RdCore(iatm,imod,icor,nat,ncor,ierr,ctmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: ctmp
 character*3       :: atom
 dimension         :: ic(2,nat)
 logical           :: ifind

 ierr = 1
 ncor = 0
 ifrm = 0    ! 0 [CORE] or 1 [PSEUDO]

 rewind(imod)
! search [Core] / [PSEUDO]
 do while(.true.)
   read(imod,"(a100)",end=1100)ctmp
   if(LEN_TRIM(ctmp) == 0 .or. index(ctmp,'[') == 0) cycle
   call charl2u(ctmp)
   if(index(ctmp,'[CORE]') > 0) exit
   if(index(ctmp,'[PSEUDO]') > 0) then
     ifrm = 1
     exit
   end if
 end do

 ic=0
 rewind(iatm)
 read(iatm,*)
 do i=1,nat
   read(iatm,*)ctmp,IA,ic(1,i)
 end do

! read core information
 if(ifrm == 0) then
!  [CORE]
   do while(.true.)
     read(imod,"(a100)",end=1000)ctmp
     if(LEN_TRIM(ctmp) == 0 .or. index(ctmp,'[') /= 0)goto 1000

     k=index(ctmp,":")
     if(k <= 1) goto 9010

     read(ctmp(k+1:),*,err=9010,end=9010) icore
!    check: icore
     if(icore < 0 .or. icore > 120) goto 9035

     read(ctmp(1:k-1),*,err=9010,end=9010) atom
     call charl2u(atom)
     call trulen(atom,I,J,K)
     K=ichar(atom(I:I))
     if( (K >= 65) .and. (K <= 90) ) then
       do L=I,J
         K=ichar(atom(L:L))
         if( (K < 65) .or. (K > 90) ) goto 9020
       end do
       call ElemZA(0,atom,za,za)
       IZ = nint(za)
!      check: ZA > icore
       if(IZ <= icore) goto 9040
       ifind = .false.
!      search all atoms with ZA = IZ
       do L=1,nat
         if(ic(1,L) == IZ) then
           ifind = .true.
           ic(2,L) = icore
         end if
       end do
       if(.not. ifind) goto 9050

     else if( (K >= 48) .and. (K <= 57) ) then
       do L=I,J
         K=ichar(atom(L:L))
         if( (K < 48) .or. (K > 57) ) goto 9020
       end do
       read(atom,*)IA
       IZ = ic(1,IA)

!      check: IA <= NAtom
       if(IA < 1 .or. IA > nat) goto 9030
!      check: ZA(IA) > icore
       if(IZ <= icore) goto 9040

       ic(2,IA) = icore

     else
       goto 9020
     end if

!    check ZA vs. icore: icore must be an even number (4f & 5f metals are excluded)
!    if(IZ < 57 .or. IZ > 103 .or. (IZ > 71 .and. IZ < 89) ) then
     if(mod(icore,2) /= 0) goto 9060
!    end if
   end do

 else
!  [PSEUDO]
   do while(.true.)
     read(imod,"(a100)",end=1000)ctmp
     if(LEN_TRIM(ctmp) == 0 .or. index(ctmp,'[') /= 0)goto 1000

     read(ctmp,*,err=9015,end=9015) atom,IA,icore

     IZ = ic(1,IA)
     icore = IZ - icore
!    check: icore
     if(icore < 0 .or. icore > 120) goto 9035

!    check: IA <= NAtom
     if(IA < 1 .or. IA > nat) goto 9030
!    check: ZA(IA) > icore
     if(IZ <= icore) goto 9040

     ic(2,IA) = icore

!    check ZA vs. icore: icore must be an even number (4f & 5f metals are excluded)
!    if(IZ < 57 .or. IZ > 103 .or. (IZ > 71 .and. IZ < 89) ) then
     if(mod(icore,2) /= 0) goto 9060
!    end if
   end do

 end if

 1000  continue

! write data to icor
 ncor = 0
 rewind(icor)
 do i=1,nat
   write(icor,"(2i5)")ic(1,i),ic(2,i)
   if(ic(2,i) > 0) ncor = ncor + ic(2,i)
 end do

! print core information
 if(ncor > 0) then
   write(*,"(//,'  Core information',//,'    I    Atom       ZA    NCore',/)")
   do i=1,nat
     if(ic(2,i) > 0) then
       call ElemZA(1,atom,ic(1,i),ctmp)
       write(*,"(i5,5x,a3,2i9)")i,atom,ic(1,i),ic(2,i)
     end if
   end do
   write(*,*)
 end if

 1100  continue

 ierr = 0
 return

 9010  write(*,"(//,' ### Error when reading core data! The format is',/,5x,'Iatom: Ncore  or  Element: Ncore')")
 write(*,"(2x,a)")trim(ctmp)
 return

 9015  write(*,"(//,' ### Error when reading core data! The format is',/,5x,'Name  IAtom  ZA-Ncore')")
 write(*,"(2x,a)")trim(ctmp)
 return

 9020  write(*,"(//,' ### Wrong! Unknown element or atom index in the core data!',/)")
 write(*,"(2x,a)")trim(ctmp)
 return

 9030  write(*,"(//,' ### Error in core data: IA is out of range!',/)")
 write(*,"(2x,a)")trim(ctmp)
 return

 9035  write(*,"(//,' ### Error in core data: Ncore is out of range!',/)")
 write(*,"(2x,a)")trim(ctmp)
 return

 9040  write(*,"(//,' ### Error in core data: ZA <= NCore!',/)")
 write(*,"(2x,a)")trim(ctmp)
 return

 9050  write(*,"(//,' ### Error in core data: No such an element in the molecule!',/)")
 write(*,"(2x,a)")trim(ctmp)
 return

 9060  write(*,"(//,' ### Error in core data: odd Ncore has not been programmed!',/,' Please contact the author.',/)")
 write(*,"(2x,a)")trim(ctmp)
 return

end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! driver of overlap matrix (contracted and spherical)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine OvDriv2(inbo,nshell,nexp,nbas,MaxL,lsph,xyz,ncomp,nprim,nptr,ncshl,expn,con,SMat,scr,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: xyz(3,*),ncomp(nshell),nprim(nshell),nptr(nshell),ncshl(nshell),expn(nexp),con(nexp)
 dimension         :: ra(3),rb(3),ncat(0:4)
 dimension         :: SMat(*),scr(15*15)
 dimension         :: sblk(15*15)   ! for Cart. <lq|lq> integrals, lq <= g
 data ncat/0,1,4,10,20/

 pi=acos(-1.d0)
 NTTS=nbas*(nbas+1)/2
 call AClear(NTTS,SMat)

 IBS=0
 do ishell = 1, nshell
   ra(1) = xyz(1,ncshl(ishell))
   ra(2) = xyz(2,ncshl(ishell))
   ra(3) = xyz(3,ncshl(ishell))
   nspa=ncomp(ishell)     ! nspa & nspb: #Cart./sph. b.s. (depending on lsph) in a shell
   ityp = LQuant(nspa)    ! ityp & jtyp: 0 (s), 1 (p), 2 (d), ...
   npta=(ityp+1)*(ityp+2)/2
   i1 = nptr(ishell)
   i2 = i1 + nprim(ishell) - 1
   JBS=0
   do jshell = 1, ishell
     rb(1) = xyz(1,ncshl(jshell))
     rb(2) = xyz(2,ncshl(jshell))
     rb(3) = xyz(3,ncshl(jshell))
     nspb=ncomp(jshell)
     jtyp = LQuant(nspb)
     nptb=(jtyp+1)*(jtyp+2)/2
     rab = dist(ra,rb)
     j1 = nptr(jshell)
     j2 = j1 + nprim(jshell) - 1
!--- for contracted shells ishell and jshell
     do igto = i1,i2
       as = expn(igto)
       acn= con(igto)
       do jgto = j1,j2
         bs = expn(jgto)
         bcn= con(jgto)
!------- for primitive Cartesian GTO_i and GTO_j: sblk(nptb,npta)
         call poverlap(sblk,as,npta,ncat(ityp),ra, bs,nptb,ncat(jtyp),rb,pi,MaxL,rab,info)
           if(info /= 0) goto 9000
!------- for primitive spherical GTO_i and GTO_j: sblk(nspb,nspa)
         if(lsph /= 0 .and. (ityp > 1 .or. jtyp > 1)) call car2sph(sblk,scr,npta,nptb,nspa,nspb)
!------- do contraction for sblk(nspb,nspa)
         call AScale(nspa*nspb,acn*bcn,sblk,sblk)
         call PackLT(SMat,IBS,JBS,sblk,nspa,nspb,ishell==jshell)
       end do
     end do

     JBS=JBS+nspb
   end do
   IBS=IBS+nspa
 end do

 call noiserm(SMat,NTTS)
 write(inbo,"(' $OVERLAP')")
 write(inbo,"(2x,5e15.7e2)")(SMat(i),i=1,NTTS)
 write(inbo,"(' $END')")

 9000  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Removal of numerical noise before printing array A.
! Some compilers print stars (***) if ABS(A(i)) <= 1.0d-100.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine noiserm(A,N)
 implicit real(kind=8) (a-h,o-z)
 parameter(eps=1.0d-20,zero=0.0d0)
 dimension         :: A(*)

 do i=1,N
   if(abs(A(i)) < eps) A(i)=zero
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! put overlap integrals of ci*cj*<IGTO|JGTO> into overlap matrix S.
! IBS and JBS are row and column indices which have been finished already.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine PackLT(S,IBS,JBS,si,nspa,nspb,LT)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: S(*),si(nspb,nspa)
 logical           :: LT

 do i=1,nspa
   ii=IBS+i
   jj=JBS
   kk=IdxNTT(jj,ii)
   nspb2=nspb
   if(LT) nspb2=i
   do j=1,nspb2
     kk=kk+1
     S(kk)=S(kk)+si(j,i)
   end do
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! converts Cartesian matrix s to spherical matrix, and save to s:
! amap^T * s(npta x nptb) * bmap --> s(nspa x nspb)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine car2sph(s,tmp,npta,nptb,nspa,nspb)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: s(nptb,npta),tmp(*)
! dmap, fmap, and gmap have been initialized in sph2car
 common/carsph/dmap(6,5),fmap(10,7),gmap(15,9)

! First half of transformation:
 if(nptb <= 3)then        ! S, P
   call acopy(nptb*npta,s,tmp)
 else if(nptb == 6)then   ! Cart. D
   call MatMult(2,nspb,nptb,npta,dmap,s,tmp)
 else if(nptb == 10)then  ! Cart. F
   call MatMult(2,nspb,nptb,npta,fmap,s,tmp)
 else if(nptb == 15)then  ! Cart. G
   call MatMult(2,nspb,nptb,npta,gmap,s,tmp)
 end if

! Second half of transformation:
 if(npta <= 3)then        ! S, P
   call acopy(nspa*nspb,tmp,s)
 else if(npta == 6)then   ! Cart. D
   call MatMult(1,nspb,npta,nspa,tmp,dmap,s)
 else if(npta == 10)then  ! Cart. F
   call MatMult(1,nspb,npta,nspa,tmp,fmap,s)
 else if(npta == 15)then  ! Cart. G
   call MatMult(1,nspb,npta,nspa,tmp,gmap,s)
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Mode = 1: C = A * B
!        2: C = A^T * B
!        3: C = A * B^T
!        4: C = A^T * B^T
! where C(MxN), op(A)(MxL), and op(B)(LxN)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine MatMult(Mode,M,L,N,A,B,C)
 implicit real(kind=8) (a-h,o-z)
 parameter(Zero=0.d0,One=1.d0)
 dimension         :: A(*),B(*),C(*)

 LDC=M
 if(Mode == 1)then
   LDA=M
   LDB=L
   call DGEMM('N','N',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
 else if(Mode == 2)then
   LDA=L
   LDB=L
   call DGEMM('T','N',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
 else if(Mode == 3)then
   LDA=M
   LDB=N
   call DGEMM('N','T',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
 else if(Mode == 4)then
   LDA=L
   LDB=N
   call DGEMM('T','T',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! overlap integrals for primitive Cartesian GTO_i and GTO_j
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine poverlap(s6d, as,npta,ioffst,ra, bs,nptb,joffst,rb,pi,MaxL,rab,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: s6d(nptb,npta),ra(3),rb(3)

 do icat=1,npta
   ipat=icat+ioffst
!  normalization factor
   fna=fnorm_lmn(as,ipat)
   call pattml(ipat,l1,m1,n1,info)
     if(info /= 0) goto 9000
   do jcat=1,nptb
     jpat=jcat+joffst
!    normalization factor
     fnb=fnorm_lmn(bs,jpat)
     call pattml(jpat,l2,m2,n2,info)
       if(info /= 0) goto 9000
     call overlap2(s6d(jcat,icat),  l1,m1,n1,as,ra,fna,  l2,m2,n2,bs,rb,fnb,  pi,MaxL,rab)
   end do
 end do

 9000  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! calculate an overlap matrix element
!              <as(ra);l1,m1,n1 | bs(rb);l2,m2,n2>
! another version
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine overlap2(s,  l1,m1,n1,as,ra,fna,  l2,m2,n2,bs,rb,fnb,  pi,MaxL,rab)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: ra(3),rb(3),p(3),dgn(0:MaxL),pan(0:MaxL,3),pbn(0:MaxL,3)
 data one/1.d0/
 save one

! gamma = as + bs and (2*gamma)^-n
 g=as+bs
 dg=g+g
 dgn(0)=one
 do i=1,MaxL
   dgn(i)=dgn(i-1)/dg
 end do
 tmp1=sqrt(pi/g)

 s=fna*fnb*exp(-as*bs*rab*rab/g)*tmp1*tmp1*tmp1

! P point
 p(1)=(as*ra(1)+bs*rb(1))/g
 p(2)=(as*ra(2)+bs*rb(2))/g
 p(3)=(as*ra(3)+bs*rb(3))/g

! pa^n and pb^n
 do j=1,3
   pan(0,j)=one
   pbn(0,j)=one
 end do
 if(MaxL > 0)then
   do j=1,3
     pan(1,j)=p(j)-ra(j)
     pbn(1,j)=p(j)-rb(j)
   end do
   do i=2,MaxL
     do j=1,3
       pan(i,j)=pan(i-1,j)*pan(1,j)
       pbn(i,j)=pbn(i-1,j)*pbn(1,j)
     end do
   end do
 end if

 call integ(sx,MaxL,l1,l2,dgn,pan(0,1),pbn(0,1))
 call integ(sy,MaxL,m1,m2,dgn,pan(0,2),pbn(0,2))
 call integ(sz,MaxL,n1,n2,dgn,pan(0,3),pbn(0,3))
 s=s*sx*sy*sz

 9000  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! get LQ according to its number of components
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function LQuant(ncomp)
 implicit real(kind=8) (a-h,o-z)

 select case(ncomp)
   case(1)
     LQuant=0
   case(3)
     LQuant=1
   case(5,6)
     LQuant=2
   case(7,10)
     LQuant=3
   case(9,15)
     LQuant=4
   case default
     write(*,"(' Error in LQuant!')")
     stop
 end select

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write $CONTRACT in *.47
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine wrctr(inbo,nshell,nexp,MaxL,lsph,ncomp,nprim,nptr,expn,con,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*10      :: tag(10)
 data tag/'   NCOMP =','   NPRIM =','    NPTR =','          ','     EXP =','      CS =','      CP =','      CD =','      CF =',  &
   '      CG ='/
 dimension ncomp(nshell),nprim(nshell),nptr(nshell),expn(nexp),con(nexp),tmp(nexp)

 write(inbo,"(' $CONTRACT')")
 write(inbo,"('  NSHELL =',i7)")nshell
 write(inbo,"('    NEXP =',i7)")nexp

 nstep=10
 call lines(nshell,nstep,nline,last)
!NCOMP
 call iwrite(tag(1),tag(4),inbo,nline,last,nstep,ncomp)
!NPRIM
 call iwrite(tag(2),tag(4),inbo,nline,last,nstep,nprim)
!NPTR
 call iwrite(tag(3),tag(4),inbo,nline,last,nstep,nptr)

 nstep=4
 call lines(nexp,nstep,nline,last)
!EXP
 call fwrite(tag(5),tag(4),inbo,nline,last,nstep,expn)
!CS
 nl = 1
 call cpcon('S',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
 call fwrite(tag(6),tag(4),inbo,nline,last,nstep,tmp)
!CP
 if(MaxL >= 1)then
   nl = 3
   call cpcon('P',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
   call fwrite(tag(7),tag(4),inbo,nline,last,nstep,tmp)
 end if
!CD
 if(MaxL >= 2)then
   nl = 5
   if(lsph == 0) nl = 6
   call cpcon('D',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
   call fwrite(tag(8),tag(4),inbo,nline,last,nstep,tmp)
 end if
!CF
 if(MaxL >= 3)then
   nl = 7
   if(lsph == 0) nl = 10
   call cpcon('F',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
   call fwrite(tag(9),tag(4),inbo,nline,last,nstep,tmp)
 end if
!CG
 if(MaxL >= 4)then
   nl = 9
   if(lsph == 0) nl = 15
   call cpcon('G',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
   call fwrite(tag(10),tag(4),inbo,nline,last,nstep,tmp)
 end if

 write(inbo,"(' $END')")

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! copy contraction coefficients of a give LQ from con1 to con2 and then multiply the normalization factors
! nl: # Cartesian or spherical functions of LQ
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine cpcon(al,nl,nshell,nexp,ncomp,nprim,ex,con1,con2)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: ncomp(nshell),nprim(nshell),ex(nexp),con1(nexp),con2(nexp)
 character*1       :: al

 call AClear(nexp,con2)
 ip=0
 do i=1,nshell
   if(ncomp(i) == nl)then
     do j=1,nprim(i)
       ip = ip + 1
       con2(ip) = con1(ip) * fnorm(ex(ip),al)
     end do
   else
     ip = ip + nprim(i)
   end if
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write $BASIS in *.47
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine wrbas(inbo,nbas,nc,label)
 implicit real(kind=8) (a-h,o-z)
 character*10      :: tag(3)
 dimension         :: nc(nbas),label(nbas)
 data tag/'  CENTER =','   LABEL =','          '/

 write(inbo,"(' $BASIS')")

 nstep=10
 call lines(nbas,nstep,nline,last)
! CENTER
 call iwrite(tag(1),tag(3),inbo,nline,last,nstep,nc)
! LABEL
 call iwrite(tag(2),tag(3),inbo,nline,last,nstep,label)

 write(inbo,"(' $END')")

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write real array in the format a, n*f
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine fwrite(tag1,tag2,io,nline,last,nstep,fvec)
 implicit real(kind=8) (a-h,o-z)
 character*10      :: tag1,tag2,ac
 dimension         :: fvec(*)

 idx=0
 do i=1,nline
   if(i == 1)then
     ac=tag1
   else
     ac=tag2
   end if
   if(i < nline)then
     write(io,1110)ac,(fvec(j),j=idx+1,idx+nstep)
     idx=idx+nstep
   else
     write(io,1110)ac,(fvec(j),j=idx+1,idx+last)
   end if
 end do

 return
 1110  format(a10,4e16.7)
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write integer array in the format a, n*i
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine iwrite(tag1,tag2,io,nline,last,nstep,ivec)
 implicit real(kind=8) (a-h,o-z)
 character*10      :: tag1,tag2,ac
 dimension         :: ivec(*)

 idx=0
 do i=1,nline
   if(i == 1)then
     ac=tag1
   else
     ac=tag2
   end if
   if(i < nline)then
     write(io,1110)ac,(ivec(j),j=idx+1,idx+nstep)
     idx=idx+nstep
   else
     write(io,1110)ac,(ivec(j),j=idx+1,idx+last)
   end if
 end do

 return
 1110  format(a10,10i7)
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! count the number of lines
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine lines(n1,n2,nline,last)
 implicit real(kind=8) (a-h,o-z)

 nline=n1/n2
 last=n2
 if(mod(n1,n2) /= 0)then
   last=mod(n1,n2)
   nline=nline+1
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read contracted basis functions
! Note: the sp shells have been saved separately.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine RdConBF(igto,natm,nshell,nexp,nbas,lsph,ncomp,nprim,nptr,ncshl,expn,con,nc,label)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: ncomp(nshell),nprim(nshell),nptr(nshell),ncshl(nshell),expn(nexp),con(nexp),nc(nbas),label(nbas)
 character*1       :: lq

 iatm = 1
 ishell = 0
 iexp = 0
 ibas = 0
 rewind(igto)
 read(igto,*)    ! skip " 1  0"
 do while(.true.)
   read(igto,*)lq,ncon
   if(lq == 'E')then
     iatm = iatm + 1
     if(iatm > natm)then
       exit
     else
       read(igto,*)    ! skip " n  0"
       cycle
     end if
   end if

   ishell = ishell + 1

   nprim(ishell) = ncon

   if(ishell > 1)then
     nptr(ishell) = nptr(ishell-1)+nprim(ishell-1)
   else
     nptr(ishell) = 1
   end if

   ncshl(ishell) = iatm
!
!  Pattern in MOLDEN format:
!   5D: D 0, D+1, D-1, D+2, D-2
!       255  252  253  254  251
!   6D: xx, yy, zz, xy, xz, yz
!       201 204 206 202 203 205
!   7F: F 0, F+1, F-1, F+2, F-2, F+3, F-3
!       351  352  353  354  355  356  357
!  10F: xxx, yyy, zzz, xyy, xxy, xxz, xzz, yzz, yyz, xyz
!       301  307  310  304  302  303  306  309  308  305
!   9G: G 0, G+1, G-1, G+2, G-2, G+3, G-3, G+4, G-4
!       451  452  453  454  455  456  457  458  459
!  15G: xxxx yyyy zzzz xxxy xxxz yyyx yyyz zzzx zzzy xxyy xxzz yyzz xxyz yyxz zzxy
!       401  411  415  402  403  407  412  410  414  404  406  413  405  408  409
!
!  Labels used in NBO (see Section B.7.5 of the manual)
!
!  s     x     y     z                                               !  4 * cart s, p
!  001   101   102   103
!
!  s     px    py    pz                                              !  4 * pure s, p
!  001   101   102   103
!
!  xx    xy    xz    yy    yz    zz                                  !  6 * cart d
!  201   202   203   204   205   206
!
!  d2-   d1+   d1-   d2+   d0                                        !  5 * pure d
!  251   252   253   254   255
!
!  xxx   xxy   xxz   xyy   xyz   xzz   yyy   yyz   yzz   zzz         ! 10 * cart f
!  301   302   303   304   305   306   307   308   309   310
!
!  f0    f1+   f1-   f2+   f2-   f3+   f3-                           !  7 * pure f
!  351   352   353   354   355   356   357
!
!  xxxx  xxxy  xxxz  xxyy  xxyz  xxzz  xyyy  xyyz  xyzz  xzzz        ! 15 * cart g
!  yyyy  yyyz  yyzz  yzzz  zzzz
!  401   402   403   404   405   406   407   408   409   410
!  411   412   413   414   415
!
!  g0    g1+   g1-   g2+   g2-   g3+   g3-   g4+   g4-               !  9 * pure g
!  451   452   453   454   455   456   457   458   459
!
!  The real spherical harmonics are defined in
!  http://en.wikipedia.org/wiki/Table_of_spherical_harmonics
!
   if(lq == 'S')then
     ncomp(ishell) = 1
     label(ibas + 1) = 001
   else if(lq == 'P')then
     ncomp(ishell) = 3
     label(ibas + 1) = 101
     label(ibas + 2) = 102
     label(ibas + 3) = 103
   else if(lq == 'D')then
     if(lsph == 0) then
       ncomp(ishell) = 6
       label(ibas + 1) = 201
       label(ibas + 2) = 204
       label(ibas + 3) = 206
       label(ibas + 4) = 202
       label(ibas + 5) = 203
       label(ibas + 6) = 205
     else
       ncomp(ishell) = 5
       label(ibas + 1) = 255
       label(ibas + 2) = 252
       label(ibas + 3) = 253
       label(ibas + 4) = 254
       label(ibas + 5) = 251
     end if
   else if(lq == 'F')then
     if(lsph == 0) then
       ncomp(ishell) = 10
       label(ibas + 1) = 301
       label(ibas + 2) = 307
       label(ibas + 3) = 310
       label(ibas + 4) = 304
       label(ibas + 5) = 302
       label(ibas + 6) = 303
       label(ibas + 7) = 306
       label(ibas + 8) = 309
       label(ibas + 9) = 308
       label(ibas +10) = 305
     else
       ncomp(ishell) = 7
       label(ibas + 1) = 351
       label(ibas + 2) = 352
       label(ibas + 3) = 353
       label(ibas + 4) = 354
       label(ibas + 5) = 355
       label(ibas + 6) = 356
       label(ibas + 7) = 357
     end if
   else if(lq == 'G')then
     if(lsph == 0) then
       ncomp(ishell) = 15
       label(ibas + 1) = 401
       label(ibas + 2) = 411
       label(ibas + 3) = 415
       label(ibas + 4) = 402
       label(ibas + 5) = 403
       label(ibas + 6) = 407
       label(ibas + 7) = 412
       label(ibas + 8) = 410
       label(ibas + 9) = 414
       label(ibas +10) = 404
       label(ibas +11) = 406
       label(ibas +12) = 413
       label(ibas +13) = 405
       label(ibas +14) = 408
       label(ibas +15) = 409
     else
       ncomp(ishell) = 9
       label(ibas + 1) = 451
       label(ibas + 2) = 452
       label(ibas + 3) = 453
       label(ibas + 4) = 454
       label(ibas + 5) = 455
       label(ibas + 6) = 456
       label(ibas + 7) = 457
       label(ibas + 8) = 458
       label(ibas + 9) = 459
     end if
   end if

   do i=1,ncomp(ishell)
     ibas = ibas + 1
     nc(ibas) = iatm
   end do
!  basis functions in igto have been normalized
   do i=1,ncon
     iexp = iexp + 1
     read(igto,*)expn(iexp),con(iexp)
   end do
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! collects information of contracted basis functions
! Note: the sp shells have been saved separately.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine cbsinf(igto,natm,nshell,nexp)
 implicit real(kind=8) (a-h,o-z)
 character*1       :: lq

 iatm = 1
 nshell = 0
 nexp = 0
 rewind(igto)
 read(igto,*)    ! skip " 1  0"
 do while(.true.)
   read(igto,*)lq,ncon
   if(lq == 'E')then
     iatm = iatm + 1
     if(iatm > natm)then
       exit
     else
       read(igto,*)    ! skip " n  0"
       cycle
     end if
   end if

   nshell = nshell + 1
   nexp = nexp + ncon
   do i=1,ncon
     read(igto,*)
   end do
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! search [Program] and get the name of the program.
! [Program] is a special keyword for Molden2AIM.
! iname = 0 (default), 1 (orca), 2 (cfour), 3 (turbomole), ...
! < 0: same as 0 except the name of QC program is known.
!
! If MOLCAS uses spherical functions, iname will be reset to -6 later.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine getprog(imod,nprog,pname,iname,tmp1)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp1
 character*20      :: pname(nprog)
 1010  format(' >>> This MOLDEN file was generated by ',a,/)

! iname is known
 if(iname >= 1 .and. iname <= nprog) then
   write(*,1010)trim(pname(iname))
   return
 end if

! iname is unknown
 iname = 0
 rewind(imod)
 100   read(imod,"(100a)",end=9999)tmp1
 call charl2u(tmp1)
 if(index(tmp1,'[PROGRAM]') /= 0) goto 200
 goto 100
! FORMAT:
! [PROGRAM] pname
!      or
! [PROGRAM]
!   pname
 200   i=len_trim(tmp1)+1
 if(i < 100)then
   read(imod,"(100a)",end=9999)tmp1(i:)
   call charl2u(tmp1(i:))
 end if

 do i=1,nprog
   if(index(tmp1,trim(pname(i))) /= 0)then
     iname=i
     write(*,1010)trim(pname(iname))
     exit
   end if
 end do

 9999  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Check the NBO's .47 file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine CheckNBO(inbo,NAtom,NC,TotE1,info,ctmp)
 implicit real(kind=8) (a-h,o-z)
 parameter(tole=5.d-5,tola=1.d-6)
 character*100     :: ctmp
 allocatable       :: S(:),P(:)

 info=1
 NTT=NC*(NC+1)/2

! read S & P from the *.47 file
 rewind(inbo)
 allocate(S(NTT),P(NTT))
 do while(.true.)
   read(inbo,"(a100)",err=5000,end=5000)ctmp
   if(index(ctmp,"$OVERLAP") /= 0) then
     write(*,6010)
     read(inbo,*,err=5000,end=5000)(S(i),i=1,NTT)
   else if(index(ctmp,"$DENSITY") /= 0) then
     write(*,6020)
     read(inbo,*,err=5000,end=5000)(P(i),i=1,NTT)
     exit
   end if
 end do

 TotE2 = TracLL(NC,S,P)

 DifE=abs(TotE1-TotE2)
 DifA=DifE/dble(NAtom)
 write(*,6110)TotE1
 write(*,6120)TotE2
 write(*,6130)DifE,DifA
 if(NAtom < 30) then
   if(DifE > tole) write(*,6210)
 else
   if(DifA > tola) write(*,6210)
 end if

 info=0

 5000  deallocate(S,P)
 return

 6010  format(/,"  Reading overlap matrix...")
 6020  format("  Reading density matrix...")
 6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
 6120  format("  Analytically integrated number of electrons = ",f18.10)
 6130  format("  Difference",33x," = ",f18.10,/,"  Difference per atom",24x," = ",f18.10)
 6210  format(/,' ### Warning! Normalization check failed.')
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Check the AIM-WFN file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine CheckWFN(iwfn,MaxAtm,maxpg,MaxL,info)
 implicit real(kind=8) (a-h,o-z)
 parameter(tole=5.d-5,tola=1.d-6)
 dimension         :: r(3,MaxAtm),Expon(maxpg),CMO(maxpg),FNor(maxpg),ICent(maxpg),IType(maxpg)
 allocatable       :: smat(:)

 info=0

! read basis function from the *.WFN file
 write(*,6010)
 call RdBas(iwfn,MaxAtm,maxpg,NMO,NGauss,NAtom,r,Expon,ICent,IType,FNor,info)
   if(info /= 0) goto 5010
! compute the overlap matrix
 write(*,6020)
 allocate(smat(maxpg*(1+maxpg)/2))
 call OvDriver(smat,NGauss,IType,Expon,r,ICent,MaxL,info)
   if(info /= 0) goto 5000

! compute the number of electrons
 write(*,6030)
 TotE1=0.d0
 TotE2=0.d0
 do i=1,NMO
   call RdMO(iwfn,NGauss,Occ,CMO,FNor)
   TotE1=TotE1+Occ
   TotE2=TotE2+Occ*VSV(NGauss,CMO,smat)
 end do

 DifE=abs(TotE1-TotE2)
 DifA=DifE/dble(NAtom)
 write(*,6110)TotE1
 write(*,6120)TotE2
 write(*,6130)DifE,DifA
 if(NAtom < 30) then
   if(DifE > tole) write(*,6210)
 else
   if(DifA > tola) write(*,6210)
 end if

 5000  deallocate(smat)
 5010  return

 6010  format(/,"  Reading basis functions...")
 6020  format("  Computing the overlap matrix...")
 6030  format("  Computing the integrated number of electrons...")
 6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
 6120  format("  Analytically integrated number of electrons = ",f18.10)
 6130  format("  Difference",33x," = ",f18.10,/,"  Difference per atom",24x," = ",f18.10)
 6210  format(/,' ### Warning! Normalization check failed.')
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Check the AIM-WFX file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine CheckWFX(iwfx,MaxAtm,maxpg,MaxL,info,ctmp)
 implicit real(kind=8) (a-h,o-z)
 parameter(tole=5.d-5,tola=1.d-6)
 dimension         :: r(3,MaxAtm),Expon(maxpg),CMO(maxpg),FNor(maxpg),ICent(maxpg),IType(maxpg)
 allocatable       :: smat(:),Occ(:)
 character*100     :: ctmp
 character*42      :: tag

 info=0

! read basis function from the *.WFX file
 write(*,6010)
 call RdBsx(iwfx,MaxAtm,maxpg,NMO,NGauss,NAtom,r,Expon,ICent,IType,FNor,ctmp,tag,info)
   if(info /= 0) goto 5010

! compute the overlap matrix
 write(*,6020)
 allocate(smat(maxpg*(1+maxpg)/2))
 allocate(Occ(NMO))
 call OvDriver(smat,NGauss,IType,Expon,r,ICent,MaxL,info)
   if(info /= 0) goto 5000

! Occ
 rewind(iwfx)
 tag = "<Molecular Orbital Occupation Numbers>"
 do while(.true.)
   read(iwfx,"(a100)",end=5020)ctmp
   if(index(ctmp,tag(1:38)) /= 0) exit
 end do
 read(iwfx,*,err=5020,end=5020) (Occ(i),i=1,NMO)

! MO block
 rewind(iwfx)
 tag = "<Molecular Orbital Primitive Coefficients>"
 do while(.true.)
   read(iwfx,"(a100)",end=5020)ctmp
   if(index(ctmp,tag(1:42)) /= 0) exit
 end do

! compute the number of electrons
 write(*,6030)
 TotE1=0.d0
 TotE2=0.d0
 do i=1,NMO
   call RdMOx(iwfx,NGauss,CMO,FNor,ctmp,tag,info)
   if(info /= 0) goto 5000
   TotE1=TotE1+Occ(i)
   TotE2=TotE2+Occ(i)*VSV(NGauss,CMO,smat)
 end do

 DifE=abs(TotE1-TotE2)
 DifA=DifE/dble(NAtom)
 write(*,6110)TotE1
 write(*,6120)TotE2
 write(*,6130)DifE,DifA

 if(NAtom < 30) then
   if(DifE > tole) write(*,6210)
 else
   if(DifA > tola) write(*,6210)
 end if

 5000  deallocate(smat)
 deallocate(Occ)
 5010  return

 5020  write(*,"(/,' ### Error when reading MO in the WFX file!')")
 info=1
 goto 5000

 6010  format(/,"  Reading basis functions...")
 6020  format("  Computing the overlap matrix...")
 6030  format("  Computing the integrated number of electrons...")
 6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
 6120  format("  Analytically integrated number of electrons = ",f18.10)
 6130  format("  Difference",33x," = ",f18.10,/,"  Difference per atom",24x," = ",f18.10)
 6210  format(/,' ### Warning! Normalization check failed.')
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read MO coefficients from the *.WFX file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine RdMOx(iwfx,NGauss,CMO,FNor,ctmp,tag,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: CMO(*),FNor(*)
 character*100     :: ctmp
 character*12      :: tag

 tag = "</MO Number>"
 info= 0
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:12)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010)(CMO(i),i=1,NGauss)

 do i=1,NGauss
   CMO(i)=CMO(i)/FNor(i)
 end do
 return

 9010  write(*,"(/,' ### Error when reading MO in the WFX file!')")
 info=1
 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read basis function from the *.WFX file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine RdBsx(iwfx,MaxAtm,MaxPG,NMO,NGauss,NAtom,r,Expon,ICent,IType,FNor,ctmp,tag,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: r(3,*),Expon(*),ICent(*),IType(*),FNor(*)
 character*100     :: ctmp
 character*42      :: tag

 info=0

! NMO
 rewind(iwfx)
 tag = "<Number of Occupied Molecular Orbitals>"
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:39)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010) NMO

! NAtom
 rewind(iwfx)
 tag = "<Number of Nuclei>"
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:18)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010) NAtom

! NGauss
 rewind(iwfx)
 tag = "<Number of Primitives>"
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:22)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010) NGauss

! check
 if(NAtom /= MaxAtm) goto 9920
 if(NGauss /= MaxPG) goto 9930

! coordinates
 rewind(iwfx)
 tag = "<Nuclear Cartesian Coordinates>"
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:31)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010) ((r(i,j), i=1,3), j=1,NAtom)

! GTO Center
 rewind(iwfx)
 tag = "<Primitive Centers>"
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:19)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010) (ICent(i),i=1,NGauss)

! GTO Type
 rewind(iwfx)
 tag = "<Primitive Types>"
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:17)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010) (IType(i),i=1,NGauss)

! GTO Exponent
 rewind(iwfx)
 tag = "<Primitive Exponents>"
 do while(.true.)
   read(iwfx,"(a100)",end=9010)ctmp
   if(index(ctmp,tag(1:21)) /= 0) exit
 end do
 read(iwfx,*,err=9010,end=9010) (Expon(i),i=1,NGauss)

! compute normalization factors
 do i=1,NGauss
   FNor(i)=fnorm_lmn(Expon(i),IType(i))
 end do

 1000  return

 9010  write(*,"(/,' ### Error when reading the WFX file!')")
 info=1
 return
 9920  write(*,"(/,' ### Wrong! NAtom /= MaxAtm:',2i8)")NAtom,MaxAtm
 info=1
 return
 9930  write(*,"(/,' ### Wrong! NGauss /= MaxPG:',2i8)")NGauss,MaxPG
 info=1
 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! v * S * v', S is a symmetric L.T. matrix
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function VSV(N,v,s)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: v(N),s(*)

 p=0.d0
 do i=1,N
   k=IdxNTT(1,i)-1
   do j=1,i-1
     k=k+1
     q=v(j)*s(k)*v(i)
     p=p+q+q
   end do
   k=k+1
   q=v(i)*s(k)*v(i)
   p=p+q
 end do
 VSV=p

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Trace of the product of lower triangular matrices A and B.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function TracLL(N,A,B)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: A(*), B(*)

 Su = 0.0d0
 Do I = 1, N
   II = (I*(I-1))/2
   Do J = 1, I-1
     Su = Su + (A(II+J)+A(II+J))*B(II+J)
   End Do
   Su = Su + A(II+I)*B(II+I)
 End Do

 TracLL = Su
 Return
End

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! It returns the position of element (J,I) in a L.T. matrix.
! J must be .LE. I. It doesn't work if J > I.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function IdxNTT(J,I)
 implicit real(kind=8) (a-h,o-z)

 IdxNTT=J+(I-1)*I/2

 Return
End

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read MO coefficients from the *.WFN file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine RdMO(iwfn,NGauss,Occ,CMO,FNor)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: CMO(*),FNor(*)

 read(iwfn,"(34x,f13.7)")Occ
 read(iwfn,"(5d16.8)")(CMO(i),i=1,NGauss)
 do i=1,NGauss
   CMO(i)=CMO(i)/FNor(i)
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! driver of overlap matrix
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine OvDriver(s,NGauss,IType,Expon,r,ICent,MaxL,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: s(*),r(3,*),Expon(*),ICent(*),IType(*)

 k=0
 do i=1,NGauss
   do j=1,i
     k=k+1
     call overlap(s(k),IType(i),Expon(i),r(1,ICent(i)),IType(j),Expon(j),r(1,ICent(j)),MaxL,info)
     if(info /= 0) goto 100
   end do
 end do

 100   return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read basis function from the *.WFN file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine RdBas(iwfn,MaxAtm,MaxPG,NMO,NGauss,NAtom,r,Expon,ICent,IType,FNor,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: r(3,*),Expon(*),ICent(*),IType(*),FNor(*)

 info=0
 rewind(iwfn)
 read(iwfn,"(/,16x,i7,13x,i7,11x,i9)")NMO,NGauss,NAtom
 if(NAtom /= MaxAtm)then
   write(*,"(/,' ### Wrong! NAtom /= MaxAtm:',2i8)")NAtom,MaxAtm
   info=1
   goto 1000
 end if
 if(NGauss /= MaxPG)then
   write(*,"(/,' ### Wrong! NGauss /= MaxPG:',2i8)")NGauss,MaxPG
   info=1
   goto 1000
 end if

 do i=1,NAtom
   read(iwfn,"(24x,3f12.8)")r(1,i),r(2,i),r(3,i)
 end do

 read(iwfn,"(20x,20i3)")(ICent(i),i=1,NGauss)
 read(iwfn,"(20x,20i3)")(IType(i),i=1,NGauss)
 read(iwfn,"(10x,5d14.7)")(Expon(i),i=1,NGauss)

! compute normalization factors
 do i=1,NGauss
   FNor(i)=fnorm_lmn(Expon(i),IType(i))
 end do

 1000  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! check molecular charge
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine chkcharge(nchar,sumocc,iprog,ifc4,iecp,chanet,ierr)
 implicit real(kind=8) (a-h,o-z)
 character*1       :: ioc

 ierr=1
 chanet=dble(nchar-iecp)-sumocc
 write(*,"(//,' Warning: the total electron is different from the sum of occupations!',//,4x,  & 
   '#Electron        =',f10.4,/,4x,'Sum_Occupation   =',f10.4,/,4x,  &
   '#Core Electron   =',f10.4,/,4x,'Net Charge       =',f10.4,//,' The reasons may be',/,  &
   ' 1) semi-empirical Hamiltonian is used,')") dble(nchar),sumocc,dble(iecp),chanet
 if(chanet >= 0) then
   write(*,"(' 2) ionic system with net charge',f8.2,',')")chanet
 else
   write(*,"(' 2) anionic system with net charge',f8.2,',')")chanet
 end if
! C4: RHF; Q-Chem: RHF, RDFT, ROGF, RODFT
!write(*,"(' 3) beta MOs of R-/RO-SCF are not printed by CFOUR or Q-Chem, and therefore',/,  &
!  '    the occupation numbers should be multiplied by 2.0,',/,' 4) other reasons.',//,  &
!  ' Which one corresponds to your case?',/,' > ',$)")
 write(*,*) "( 3) beta MOs of R-/RO-SCF are not printed by CFOUR or Q-Chem, and therefore",  &
       "the occupation numbers should be multiplied by 2.0    4) other reasons."

!read(*,*)ioc

! select case(ioc)
!   case("1")
!     write(*,"(/,' semi-empirical Hamiltonian is not supported.')")
!     goto 9910
!   case("2")
!     docc=abs(ANINT(sumocc)-sumocc)
!     if(docc < 1.d-4)then
!       if(chanet >= 0) then
!         write(*,"(/,' This is an ionic system with net charge',f10.4)") chanet
!       else
!         write(*,"(/,' This is an anionic system with net charge',f10.4)") chanet
!       end if
!     else if(docc < 1.d-2)then
!       write(*,"(/,' Warning! Strange occupation: ',f10.4)")sumocc
!       write(*,"(/,' Please check your AIM results carefully.')")
!     else
!       write(*,"(/,' Error! Strange occupation: ',f10.4)")sumocc
!       goto 9910
!     end if
!   case("3")
!     write(*,"(///,' Occupations are multiplied by 2.0...')")
!     ifc4=2
!     chanet=dble(nchar-iecp)-sumocc*dble(ifc4)
!     write(*,"(/,4x,                     &
!       '#Electron        =',f10.4,/,4x,  &
!       'Modified Sum_Occ =',f10.4,/,4x,  &
!       '#Core Electron   =',f10.4,/,4x,  &
!       'Net Charge       =',f10.4,/)") dble(nchar),sumocc*dble(ifc4),dble(iecp),chanet
!!    for Q-Chem
!     if(iprog == 0)write(*,"(' *** WARNING ***',/,'  There is a BUG in Q-Chem RO-SCF. In this case, please correct the',/,  &
!       '  occupation numbers of singly occupied MOs manually.')")
!   case default
!     write(*,"(/,' Unknown reason. Please report the problem.')")
!!    goto 9910
! end select
!!call xcontinue
 ierr=0

 9910  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! define file names
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine filename(imod,fmdn,fwfn,fwfx,fnbo)
 implicit real(kind=8) (a-h,o-z)
 character*57      :: fwfn,fwfx,fnbo,fmod(2)
 character*64      :: fmdn
 character*7       :: exten(8)
 data exten/'.mol   ','.MOL   ','.mold  ','.MOLD  ','.molden','.MOLDEN','.gab   ','.GAB   '/

!write(*,"(///)")
!100  write(*,"(' Type in the MOLDEN/GABEDIT file name within 50 characters:',/,  &
!       ' (extension mol/mold/molden/gab can be omitted; default: MOLDEN)',/,' > ',$)")
!read(*,"(a50)")fmod(1)(:)
 fmod(1)='MOLDEN'
 lstr=nonspace(fmod(1)(:))
 lend=LEN_TRIM(fmod(1)(:))
 if(lend == 0)then                 ! use default file name
   lstr=1
   lend=6
   fmod(1)(1:6)='MOLDEN'
 end if
 open(imod,file=fmod(1)(lstr:lend),status='old',err=110)
 iinp=1
 goto 300
 110  if(fmod(1)(lend:lend) == '.')lend=lend-1
 iinp=2
 do i=1,8
   fmod(2)(:)=fmod(1)(lstr:lend)//trim(exten(i))
   open(imod,file=fmod(2)(:),status='old',err=120)
   goto 300
 120  continue
 end do
 write(*,"(//,' ### Wrong! These MOLDEN/GABEDIT files do not exist!')")
 write(*,"(1x,a)")fmod(1)
 do i=1,8
   write(*,"(1x,a)")fmod(1)(lstr:lend)//trim(exten(i))
 end do
 write(*,"(/,' Please try again.',/)")
!goto 100

 300  write(*,"(/,' The MOLDEN/GABEDIT file ',a,' has been found.',/,1x,77('_'),/)") trim(fmod(iinp))
! define the *.wfn/wfx/47 file name
 lend2=index(fmod(iinp),'.',.true.)
 if(lend2 > 1) lend = lend2-1
 fmdn=fmod(iinp)(lstr:lend)//'_new.molden'
 fwfn=fmod(iinp)(lstr:lend)//'.wfn'
 fwfx=fmod(iinp)(lstr:lend)//'.wfx'
 fnbo=fmod(iinp)(lstr:lend)//'.47'

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! make sure that iprog matches with lsph
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine chkbstyp(lsph,iprog,MaxL,ierr)
 implicit real(kind=8) (a-h,o-z)

 ierr=0
 if(lsph == 0 .and. MaxL > 1 .and. iprog == 1)then
!  orca: spherical b.s. is used; for Cartesian b.s. (in a future version?), you should do some tests.
   write(*,"(' ### Wrong! ORCA does not use Cartesian b.s.!')")
   ierr=1
 else if(lsph /= 0 .and. MaxL > 1 .and. iprog == 2)then
!  cfour: Cartesian b.s. is used; for spherical b.s. (in a future version?), you should do some tests.
   write(*,"(' ### Wrong! CFOUR does not print MOs in spherical b.s.!')")
   ierr=1
 else if(lsph /= 0 .and. MaxL > 1 .and. iprog == 3)then
!  turbomole: Cartesian b.s. is used; for spherical b.s. (in a future version?), you should do some tests.
   write(*,"(' ### Wrong! TURBOMOLE does not print MOs in spherical b.s.!')")
   ierr=1
 else if(lsph /= 0 .and. MaxL > 1 .and. iprog == 4)then
!  jaguar: Cartesian b.s. is used; for spherical b.s. (in a future version?), you should do some tests.
   write(*,"(' ### Wrong! Jaguar does not print MOs in spherical b.s.!')")
   ierr=1
 else if(lsph /= 0 .and. MaxL > 1 .and. iprog == 5)then
!  aces2: Cartesian b.s. is used; for spherical b.s. (in a future version?), you should do some tests.
   write(*,"(' ### Wrong! ACES2 does not print MOs in spherical b.s.!')")
   ierr=1
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! print a title
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine writitle(iwfn,fwfn,ver,dt)
 implicit real(kind=8) (a-h,o-z)
 character*57      :: fwfn
 character*10      :: dt
 character*5       :: ver
 character*50      :: texdate

 OPEN(iwfn,FILE=fwfn)
 rewind(iwfn)

! if fdate doesn't work, just use this line
! write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt

 call fdate(texdate)
 call trulen(texdate,L1,L2,length)
 write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,'Time: ',a24)")ver,dt,texdate(L1:L2)

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! print a head
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine headprt(ver,dt)
 implicit real(kind=8) (a-h,o-z)
 character*10      :: dt
 character*5       :: ver

 write(*,"(//,1x,77('*'),/,31x,            '*  Molden2AIM  *',/,26x,       'Version ',a5,',  ',a10,/,  &
   6x,'It converts the format from MOLDEN to AIM-WFN, AIM-WFX, and NBO-47.',/,1x,77('*'),/)")ver,dt
 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! print supporting information
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine SuppInf
 implicit real(kind=8) (a-h,o-z)

 write(*,"(' Supported programs:',/,                                                   &
   '  1) MOLPRO',/,                                                                    &
   '  2) MOLCAS (for Cart. functions, insert [PROGRAM] MOLCAS into MOLDEN file)',/,    &
   '  3) deMon2k',/,                                                                   &
   '  4) Q-Chem (spherical SPDF or Cartesian SPD basis functions)',/,                  &
   '  5) CFour (fix reorderdf.F, and insert [PROGRAM] CFOUR into MOLDEN file)',/,      &
   '  6) Turbomole (insert [PROGRAM] TURBOMOLE into MOLDEN file)',/,                   &
   '  7) ORCA (insert [PROGRAM] ORCA into MOLDEN file)',/,                             &
   '  8) Columbus (Natural orb. from MCSCF or CI with Cartesian SPDF functions;',/,    &
   '     thanks to Dr. Marat Talipov for testing)',/,                                  &
   '  9) Priroda (thanks to Dr. Evgeniy Pankratyev for testing)',/,                    &
   ' 10) Dalton (> 2013; HF/DFT/MP2/MCSCF with spherical functions)',/,                &
   ' 11) TeraChem (SPDF basis functions)',/,                                           &
   ' 12) ACES-II 2.9 (fix reorder.F, and insert [PROGRAM] ACES2 into MOLDEN file)',/,  &
   ' 13) NWChem (>= 6.8) by MOLDEN_NORM JANPA or NONE',/,                              &
   ' 14) BDF (thanks to Dr. Bingbing Suo for testing)',/,                              &
   ' 15) PSI4 (spherical functions only; insert [PROGRAM] PSI4 into MOLDEN file)',/,   &
   ' 16) CADPAC',/,                                                                    &
   ' 17) MRCC (for Cart. functions, insert [PROGRAM] MRCC into MOLDEN file)',/,        &
   ' 18) NBO6 (> May.2014, insert [PROGRAM] NBO6 into MOLDEN file)',/,                 &
   ' 19) Molden (the Molden program can read MOs from the output file of some',/,      &
   '     QC programs, and save a MOLDEN file)',/,                                      &
   ' 20) Gabedit (the GAB file is compatible)',/,                                      &
   ' 21) MultiWFN (it can read the fchk file of Gaussian and Q-Chem, and save',/,      &
   '     a MOLDEN file)',/,                                                            &
   ' 22) PySCF'                                                                        &
   )")

 write(*,"(/,' Programs to be tested:      1) Bagel      2) NRLMOL     3) SeqQuest',/, &
             '                             4) StoBe')")

 write(*,"(/,' Unsupported programs:       1) ADF        2) Jaguar')")

!call xcontinue

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! generate a standard Molden file with Cartrsian basis functions.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine genmdn(fmdn,inmd,iatm,igto,imol,imo0,icor,ver,dt,nat,nmotot,ncarmo,ngc,ifc4,iecp,tmp)
 implicit real(kind=8) (a-h,o-z)
 parameter(maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 character*5       :: ver
 character*10      :: dt
 character*50      :: texdate
 character*64      :: fmdn
 character*100     :: tmp

 OPEN(inmd,FILE=fmdn)
 rewind(inmd)

! title
 write(inmd,"('[Molden Format]')")
 write(inmd,"('[Title]')")
! if fdate doesn't work, just use this line
! write(inmd,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt

 call fdate(texdate)
 call trulen(texdate,L1,L2,length)
 write(inmd,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,'Time: ',a24)")ver,dt,texdate(L1:L2)
 write(inmd,*)

! coordinates
 rewind(iatm)
 read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
 if(iu == 0) then
   write(inmd,"('[Atoms] Angs')")
 else
   write(inmd,"('[Atoms] AU')")
 end if

 do i=1,nat
   read(iatm,"(100a)")tmp
   write(inmd,"(100a)")trim(tmp)
 end do

! #core
 if(iecp > 0)then
   write(inmd,"('[PSEUDO]')")
   rewind(icor)
   do i=1,nat
     read(icor,*) iz, j
     call ElemZA(1,tmp,iz,tmp)
     write(inmd,"(a3,1x,2i6)") tmp(1:3), i, iz-j
   end do
 end if

! the blank line before [GTO] is not allowed by MOLDEN!!!

! basis functions
 rewind(igto)
 write(inmd,"('[GTO]')")
 200  read(igto,"(100a)",end=300)tmp
 if(Len_trim(tmp) == 0) goto 200
 if(index(tmp,' E 0') /= 0)then
   write(inmd,*)
 else
   write(inmd,"(100a)")trim(tmp)
 end if
 goto 200
 300  write(inmd,*)

! MO in Cartesian basis functions
 rewind(imol)
 rewind(imo0)
 write(inmd,"('[MO]')")
 do i=1,nmotot
!  read "Sym=", "Ene=", "Spin=", and "Occup=" from imo0
!  Gabedit doesn't recognize UPPERCASE keywords!
   600  read(imo0,"(100a)")tmp
   j=index(tmp,'=')
   if(j /= 0)then
     call charl2u(tmp)
!    Occup=
     if(index(tmp(1:j-1),'OCCUP') /= 0)then
       read(tmp(j+1:),*)x
       write(inmd,"(' Occup=',f18.8)")x*dble(ifc4)
!    Ene=
     else if(index(tmp(1:j-1),'ENE') /= 0)then
!      in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
       x = 0.d0
       if(index(tmp(j+1:),'***') == 0) then
         read(tmp(j+1:),*)x
         x = sign(min(abs(x), 1.d6), x)
       end if
       write(inmd,"(' Ene=',f20.8)")x
!    Sym=
     else if(index(tmp(1:j-1),'SYM') /= 0)then
       write(inmd,"(' Sym=',a)")trim(tmp(j+1:))
!    Spin=
     else if(index(tmp(1:j-1),'SPIN') /= 0)then
       if(index(tmp(j+1:),'ALPHA') /= 0)then
         write(inmd,"(' Spin= Alpha')")
       else
         write(inmd,"(' Spin= Beta')")
       end if
     else
       write(inmd,"(100a)")trim(tmp)
     end if

     goto 600
   end if

   do j=1,ncarmo-1
     read(imo0,*)
   end do
!  read MO coefficients from imol
   read(imol,*)
   read(imol,*)
   do j=1,ngc
     read(imol,*)idx,cf
     write(inmd,"(i5,f20.10)")idx,cf*scalmo(j)
   end do
 end do
 write(inmd,*)

 write(*,"(//,'  A new Molden file is generated successfully!',/,'  File Name = ',a)")trim(fmdn)

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! print information at the final step for wfn
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine finalwfn(fwfn,iecp,MaxL)
 implicit real(kind=8) (a-h,o-z)
 character*57      :: fwfn

 write(*,"(//,'  A WFN file is generated successfully!',/,'  File Name = ',a)")trim(fwfn)
 if(iecp > 0)then
   write(*,"(/,2x,'Because of PP (ECP or MCP), please use',/,3x,'MultiWFN 3.2.1 or higher version',/)")
 else if(MaxL < 4)then
   write(*,"(/,2x,'Please use',/,3x,'AIM2000, AIMALL, AIMPAC, AIMPAC2, AIM-UC, CheckDen, Critic2, DensToolKit,',/,  &
     3x,'DGrid, MORPHY, MultiWFN, ORBKIT, PAMoC, ProMolden, TopChem, TopMoD,',/,3x,'or XAIM',/)")
 else
   write(*,"(/,2x,'G-functions are found! Please use',/,3x,  &
     'AIM2000 (Ver. 2013), AIMALL, AIM-UC, Critic2, DGrid, MultiWFN, ORBKIT,',/,3x,'or TopChem',/)")
 end if
 write(*,"('  to analyse the electron density distribution.')")
 if(iecp > 0) write(*,"(/,9x,'>>> Please consult MultiWFN manual (sec. 5.7) for details <<<')")

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! print information at the final step for wfx
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine finalwfx(fwfn,iecp,iunknw,MaxL)
 implicit real(kind=8) (a-h,o-z)
 character*57      :: fwfn

 write(*,"(//,'  A WFX file is generated successfully!',/,'  File Name = ',a)")trim(fwfn)
! with ECP/MCP
 if(iecp > 0) then
   if(MaxL < 4)then
     write(*,"(/,2x,'ECPs/MCPs are found! Please use',/,3x,'AIMALL, Critic2, DensToolKit, MultiWFN, or ORBKIT',/)")
   else
     write(*,"(/,2x,'ECPs/MCPs and G-functions are found! Please use',/,3x,'AIMALL, Critic2, MultiWFN, or ORBKIT',/)")
   end if
! without ECP/MCP
 else
   if(MaxL < 4)then
     write(*,"(/,2x,'Please use',/,3x,'AIMALL, Critic2, DensToolKit, GPView, MultiWFN, or ORBKIT',/)")
   else
     write(*,"(/,2x,'G-functions are found! Please use',/,3x,'AIMALL, Critic2, GPView, MultiWFN, or ORBKIT',/)")
   end if
 end if
 write(*,"('  to analyse the electron density distribution.')")
 if(iunknw == 0) then
   write(*,"(//,6x,65('-'),/, 6x,'>>> Please correct the UNKNOWN terms in the WFX file manually <<<',/, 6x,65('-'),/)")
 else
   write(*,"(//,6x,65('-'),/, 6x,'>>> Please modify Energy and Virial Ratio in WFX if necessary <<<',/, 6x,65('-'),/)")
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! print information at the final step for nbo's 47 file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine finalnbo(fnbo,MaxL)
 implicit real(kind=8) (a-h,o-z)
 character*57      :: fnbo

 write(*,"(//,'  A NBO 47 file is generated successfully!',/,'  File Name = ',a)")trim(fnbo)

 if(MaxL > 3) write(*,"(/,' Warning: G-functions are not fully supported by NBO 3.0.',/,  &
   ' Delete the $CONTRACT data block manually if NBO 3.0 is used.')")

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! A new version of the subroutine checkcar for shortened MO arrays.
! Count the number of basis functions from MO, which can be used to judge cartesian/spherical basis functions.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine checkcar2(nc,ishort,ifmo,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp

 imod=44
 nc=0
 ifmo=1
 ishort=0
 maxnc=0
 iold=0

! count the number of CGTO
 rewind(imod)

 500  read(imod,"(100a)",end=550)tmp
 call charl2u(tmp)
 if(index(tmp,'[MO]') /= 0) goto 600
 goto 500

 550  write(*,*)"*** Wrong! [MO] can not be found!"
 ifmo=0
 return

 600  read(imod,"(100a)",end=9999)tmp
 if(len_trim(tmp) == 0) goto 600
 if(index(tmp,'=') /= 0) goto 600
 if(index(tmp,'[') /= 0) goto 9999

 nc=0
 610  read(tmp,*)inew
 nc=nc+1
 maxnc=max(maxnc,inew)
 620  read(imod,"(100a)",end=9990)tmp
 if(len_trim(tmp) == 0) goto 620
 if(index(tmp,'=') /= 0)then
   if(nc < maxnc) ishort=1
   goto 600
 end if
 if(index(tmp,'[') /= 0) goto 9990
 goto 610

 9990  if(nc < maxnc) ishort=1
 9999  nc=maxnc

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Save a wavefunction file in wfx format.
!
!     Note:
!
!     1. Fortran D (or d) descriptor for numbers is NOT allowed.
!
!     2. All data must be in atomic units.
!
!     3. Comment lines start with the # character must NOT be used inside
!        data sections, i.e., between opening and closing tags.
!
!     4. MO should be in the order doubly, singly Alpha, singly Beta.
!        For RO-SCF, this means all doubly occupied MOs, then all singly
!        occupied Alpha MOs.
!        For U-SCF or post-SCF, this means all Alpha MOs then all Beta
!        MOs.
!        Within a block of MOs, the SCF MOs should be in the order of
!        increasing MO energy
!        Within a block of post-SCF natural MOs, they should be in the
!        order of decreasing occupancy.
!
!        >>>>>>>>>>>>>>>>>>>>>>>>>> Not considered at present!
!
!     5. Non-nuclear attractors can be added to the .wfx file as nuclei
!        with atomic number 0, nuclear charge 0.0 and with names begin-
!        ning with NNA (e.g., NNA8).
!        and
!        Ghost atoms can be added to the .wfx file as nuclei with atomic
!        number 0, nuclear charge 0.0 and with names beginning with Bq
!        (e.g., Bq12).  The coordinates of ghost nuclei must appear in
!        the appropriate position of the <Nuclear Cartesian Coordinates>
!        section of the .wfx file.
!
!        >>>>>>>>>>>>>>>>>>>>>>>>>> Not considered at present!
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine genwfx(iatm,igto,imol,ispn,icor,iedf,iwfx,fwfx,ver,dt,nat,nmotot,nmo,chanet,tolocc,ntote,ncar,ncarc,nedf,iecp,ifc4,  &
  ifspin,ifbeta,iunknw,ctmp)
 implicit real(kind=8) (a-h,o-z)
 parameter (maxza=120,au2ang=0.529177249d0,maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 character*57      :: fwfx
 character*10      :: dt
 character*5       :: ver
 character*100     :: ctmp
 logical           :: prtspn

 ncore = 0

 OPEN(iwfx,FILE=fwfx)
 rewind(iwfx)

! if fdate doesn't work, just use this line
! write(iwfx,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt

 call fdate(ctmp)
 call trulen(ctmp,L1,L2,length)

! Title
 call wfxlab(iwfx,0,"Title")
 write(iwfx,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,'Time: ',a24)")ver,dt,ctmp(L1:L2)
 call wfxlab(iwfx,1,"Title")

! Keywords
 call wfxlab(iwfx,0,"Keywords")
 write(iwfx,"(' GTO')")
 call wfxlab(iwfx,1,"Keywords")

! Number of Nuclei
 call wfxlab(iwfx,0,"Number of Nuclei")
 write(iwfx,"(i8)")nat
 call wfxlab(iwfx,1,"Number of Nuclei")

! Number of Occupied Molecular Orbitals
 call wfxlab(iwfx,0,"Number of Occupied Molecular Orbitals")
 write(iwfx,"(i8)")nmo
 call wfxlab(iwfx,1,"Number of Occupied Molecular Orbitals")

! Number of Perturbations
 call wfxlab(iwfx,0,"Number of Perturbations")
 write(iwfx,"(i8)")0
 call wfxlab(iwfx,1,"Number of Perturbations")

! Net Charge
 call wfxlab(iwfx,0,"Net Charge")
 write(iwfx,"(i8)")nint(chanet)
 call wfxlab(iwfx,1,"Net Charge")

! Number of Electrons (Core Electrons by ECP are excluded)
 call wfxlab(iwfx,0,"Number of Electrons")
 write(iwfx,"(i8)")ntote
 call wfxlab(iwfx,1,"Number of Electrons")

! it works only when Beta exists
 prtspn=.false.
 if(ifspin == 1 .and. ifbeta == 1) then
   elea = 0.d0
   eleb = 0.d0
   rewind(ispn)
   do i=1,nmo
     read(ispn,"(a42)")ctmp
     read(ctmp(1:2),*)ix
     read(ctmp(3:22),*)x
     if(ix == 1) then
       elea = elea + x*dble(ifc4)
     else if(ix == 2) then
       eleb = eleb + x*dble(ifc4)
     end if
   end do
   if(abs(elea+eleb-dble(ntote)) < 0.01d0 .and. abs(elea-dble(nint(elea))) < 0.01d0 .and. abs(eleb-dble(nint(eleb))) < 0.01d0)  &
     prtspn = .true.
 end if

 if(prtspn) then
   nelea = nint(elea)
   neleb = nint(eleb)
   MS = nelea - neleb + 1
 else
!  Read in Spin Multiplicity, Numbers of Alpha and Beta electrons
   do while(.true.)
     write(*,"(/,'  Type in the Spin Multiplicity:',/,'  (default: 1 for even- and 2 for odd-number of electron system)',/,  &
       ' > ',$)")
     read(*,"(a10)",err=50) ctmp
     if(len_trim(ctmp(1:10)) == 0) then
     	MS = 1
     	if(mod(ntote,2) == 1) MS = 2
     else
       read(ctmp(1:10),*,err=50) MS
     end if

     if(MS < 1 .or. MS > ntote+1) then
       write(*,"(/,'   MS is out of range! Try again.')")
       cycle
     else if(mod(ntote,2) == 0 .and. mod(MS,2) == 0) then
       write(*,"(/,'   MS must be an odd number! Try again.')")
       cycle
     else if(mod(ntote,2) == 1 .and. mod(MS,2) == 1) then
       write(*,"(/,'   MS must be an even number! Try again.')")
       cycle
     else
       exit
     end if

     50  write(*,"(/,'   Error when reading MS! Try again.')")
     cycle
   end do
   neleb = (ntote + 1 - MS) / 2
   nelea = ntote - neleb
 end if
 write(*,"(/,'  Spin Multiplicity:', i4)") MS

! Number of Alpha Electrons
 call wfxlab(iwfx,0,"Number of Alpha Electrons")
 write(iwfx,"(i8)") nelea
 call wfxlab(iwfx,1,"Number of Alpha Electrons")

! Number of Beta Electrons
 call wfxlab(iwfx,0,"Number of Beta Electrons")
 write(iwfx,"(i8)") neleb
 call wfxlab(iwfx,1,"Number of Beta Electrons")

! Electronic Spin Multiplicity (optional)
 call wfxlab(iwfx,0,"Electronic Spin Multiplicity")
 write(iwfx,"(i8)") MS
 call wfxlab(iwfx,1,"Electronic Spin Multiplicity")

! Number of Core Electrons
 call wfxlab(iwfx,0,"Number of Core Electrons")
 write(iwfx,"(i8)")iecp
 call wfxlab(iwfx,1,"Number of Core Electrons")

! Nuclear Names
 call wfxlab(iwfx,0,"Nuclear Names")
 rewind(iatm)
 read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
 do i=1,nat
   call CClear(100,ctmp)
   read(iatm,*)ctmp(1:3),j,ix
   write(ctmp(11:100),*)i
   call trulen(ctmp(11:100),len2,len3,len1)
   if(ix > 0 .and. ix <= maxza) call ElemZA(1,ctmp,ix,ctmp)
   len1=len_trim(ctmp(1:3))
   write(iwfx,"(a)")ctmp(1:len1)//ctmp(len2+10:len3+10)
 end do
 call wfxlab(iwfx,1,"Nuclear Names")

! Atomic Numbers (Z)
 call wfxlab(iwfx,0,"Atomic Numbers")
 rewind(iatm)
 read(iatm,*)
 do i=1,nat
   read(iatm,*)ctmp,j,ix
   write(iwfx,"(i8)")ix
 end do
 call wfxlab(iwfx,1,"Atomic Numbers")

! Nuclear Charges (Z-#core)
 call wfxlab(iwfx,0,"Nuclear Charges")
 rewind(iatm)
 rewind(icor)
 read(iatm,*)
 do i=1,nat
   read(iatm,*)ctmp,j,ix
   if(iecp > 0) read(icor,*) iz, ncore
   write(iwfx,"(e21.12e3)")dble(ix-ncore)
 end do
 call wfxlab(iwfx,1,"Nuclear Charges")

! Nuclear Cartesian Coordinates (in a.u.)
 call wfxlab(iwfx,0,"Nuclear Cartesian Coordinates")
 fc=1.d0
 rewind(iatm)
 read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
 if(iu == 0)fc=1.d0/au2ang
 do i=1,nat
   read(iatm,*)ctmp,ia,iz,x,y,z
   write(iwfx,"(3e21.12e3)")x*fc,y*fc,z*fc
 end do
 call wfxlab(iwfx,1,"Nuclear Cartesian Coordinates")

! Number of Primitives
 call wfxlab(iwfx,0,"Number of Primitives")
 write(iwfx,"(i8)")ncar
 call wfxlab(iwfx,1,"Number of Primitives")

! print basis functions
 call writecnt(iwfx,1,igto,imol,ncar)

!<<<<<<<<<<<<<<<<<< ECP >>>>>>>>>>>>>>>>>>
 if(iecp > 0)then
   call wfxlab(iwfx,0,"Additional Electron Density Function (EDF)")
!    Number of EDF Primitives
     call wfxlab(iwfx,0,"Number of EDF Primitives")
     write(iwfx,"(i8)")nedf
     call wfxlab(iwfx,1,"Number of EDF Primitives")
!    EDF Primitive Centers
     call wfxlab(iwfx,0,"EDF Primitive Centers")
     rewind(iedf)
     do i=1,nedf
       read(iedf,"(i5)") ix
       write(iwfx,"(i8)",advance='no') ix
       if(mod(i,5) == 0) write(iwfx,*)
     end do
     if(mod(nedf,5) /= 0) write(iwfx,*)
     call wfxlab(iwfx,1,"EDF Primitive Centers")
!    EDF Primitive Types
     call wfxlab(iwfx,0,"EDF Primitive Types")
     write(iwfx,"(5i8)") (1, i=1, nedf)
     call wfxlab(iwfx,1,"EDF Primitive Types")
!    EDF Primitive Exponents
     call wfxlab(iwfx,0,"EDF Primitive Exponents")
     rewind(iedf)
     do i=1,nedf
       read(iedf,"(5x,e21.12e3)") x
       write(iwfx,"(e21.12e3)",advance='no') x
       if(mod(i,5) == 0) write(iwfx,*)
     end do
     if(mod(nedf,5) /= 0) write(iwfx,*)
     call wfxlab(iwfx,1,"EDF Primitive Exponents")
!    EDF Primitive Coefficients
     call wfxlab(iwfx,0,"EDF Primitive Coefficients")
     rewind(iedf)
     do i=1,nedf
       read(iedf,"(26x,e21.12e3)") x
       write(iwfx,"(e21.12e3)",advance='no') x
       if(mod(i,5) == 0) write(iwfx,*)
     end do
     if(mod(nedf,5) /= 0) write(iwfx,*)
     call wfxlab(iwfx,1,"EDF Primitive Coefficients")
   call wfxlab(iwfx,1,"Additional Electron Density Function (EDF)")
 end if

! Molecular Orbital Occupation Numbers
 call wfxlab(iwfx,0,"Molecular Orbital Occupation Numbers")
 rewind(ispn)
 do i=1,nmo
   read(ispn,"(a42)")ctmp
   read(ctmp(3:22),*)x
   write(iwfx,"(e21.12e3)")x*dble(ifc4)
 end do
 call wfxlab(iwfx,1,"Molecular Orbital Occupation Numbers")

! Molecular Orbital Energies
 call wfxlab(iwfx,0,"Molecular Orbital Energies")
 rewind(ispn)
 do i=1,nmo
   read(ispn,"(a42)")ctmp
   read(ctmp(23:42),*)x
   write(iwfx,"(e21.12e3)")x
 end do
 call wfxlab(iwfx,1,"Molecular Orbital Energies")

! Molecular Orbital Spin Types
 call wfxlab(iwfx,0,"Molecular Orbital Spin Types")
 rewind(ispn)
 do i=1,nmo
   if(prtspn) then
     read(ispn,"(a42)")ctmp
     read(ctmp(1:2),*)ix
     if(ix == 1) then
       write(iwfx,"(' Alpha')")
     else if(ix == 2) then
       write(iwfx,"(' Beta')")
     end if
   else
     write(iwfx,"(' Alpha and Beta')")
   end if
 end do
 call wfxlab(iwfx,1,"Molecular Orbital Spin Types")

! normalization factor
 do i=1,ncar
   cn(i)=fnorm_lmn(expg(i),ityp(i))
 end do

! MO
 call wfxlab(iwfx,0,"Molecular Orbital Primitive Coefficients")
 rewind(imol)
 ix=0
 do i=1,nmotot
   read(imol,*)ctmp,occ
   read(imol,*)
   do j=1,ncarc
     read(imol,*)ingc,cfmo(j)
     cfmo(j)=cfmo(j)*scalmo(j)
   end do
   if(abs(occ) >= tolocc)then
     ix = ix + 1
!    MO Number
     call wfxlab(iwfx,0,"MO Number")
     write(iwfx,"(i8)")ix
     call wfxlab(iwfx,1,"MO Number")
!    N*cgto*cmo
     write(iwfx,"(5e21.12e3)") (cn(j)*conf(j)*cfmo(icmo(j)),j=1,ncar)
   end if
 end do
 call wfxlab(iwfx,1,"Molecular Orbital Primitive Coefficients")

! Energy = T + Vne + Vee + Vnn
 write(iwfx,"('# The total energy of the molecule.')")
 write(iwfx,"('# For HF and KSDFT, this is the SCF energy.')")
 write(iwfx,"('# For MP2, this is the MP2 total energy.')")
 write(iwfx,"('# For CCSD, this is the CCSD total energy.')")
 write(iwfx,"('# etc.')")
 call wfxlab(iwfx,0,"Energy = T + Vne + Vee + Vnn")
 if(iunknw == 0) then
   write(iwfx,"(' UNKNOWN')")
 else
   write(iwfx,"(e21.12e3)") 0.d0
 end if
 call wfxlab(iwfx,1,"Energy = T + Vne + Vee + Vnn")

! Virial Ratio (-V/T)
 call wfxlab(iwfx,0,"Virial Ratio (-V/T)")
 if(iunknw == 0) then
   write(iwfx,"(' UNKNOWN')")
 else
   write(iwfx,"(e21.12e3)") 2.d0
 end if
 call wfxlab(iwfx,1,"Virial Ratio (-V/T)")

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! main subroutine of EDF library.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine edfmain(icor,iedf,iecp,nat,nedf)
 implicit real(kind=8) (a-h,o-z)
 parameter(MxEDF=45)
 dimension         :: edfa(MxEDF),edfc(MxEDF)

 nedf = 0
 if(iecp < 2) return

 pi=acos(-1.d0)
 alf=pi * 4.d0

 rewind(icor)
 rewind(iedf)

 write(*,"(/,'  Generate EDF data:')")
 do i=1,nat
   read(icor,*)iz,ncore
   if(ncore > 0)then
     call EDFLIB(iz,ncore,nfun,edfa,edfc)    ! it's assumed that nfun <= 40

     if(nfun > 0) then
       nedf = nedf + nfun
       acore = 0.d0
       do j=1, nfun
         write(iedf,"(i5,2e21.12e3)") i, edfa(j), edfc(j)
         x = sqrt(pi/edfa(j))
         acore = acore + edfc(j)*x*x*x
       end do
       write(*,"('  Iatm=',i4,', ZA=',i4,', NCore=',i4,', ACore=',f14.9,': EDF data from library')") i, iz, ncore, acore
     else if(ncore > 0) then
!      Generate EDF using the tight core density function, ie.
!      alpha = 4pi, c = 8Ncore
!      It is good for small-core or medium-core ECP but worse for large-core ECP. See Eq. 9 in JPCA 115, 12879 (2011).
       c=dble(8*ncore)
       nedf = nedf + 1
       write(iedf,"(i5,2e21.12e3)") i, alf, c
       x = sqrt(pi/alf)
       acore = c*x*x*x
       write(*,"('  Iatm=',i4,', ZA=',i4,', NCore=',i4,', ACore=',f14.9,': Tight Core Function')") i, iz, ncore, acore
     end if
   end if
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! wfx: print a label
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine wfxlab(iwfx,mode,label)
 implicit real(kind=8) (a-h,o-z)
 character*(*)     :: label

 if(mode == 0) then
   write(iwfx,"('<',a,'>')")label
 else
   write(iwfx,"('</',a,'>')")label
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! calculate the normalization factor for GTO(l,m,n)
! it = 1,...,35
! Ordering type:
! S,P,D: MOLDEN, Gaussian, GAMESS, WFN, ...
! F: WFN (for MOLDEN and Gaussian, 14~19 are different)
! G: WFN, MOLDEN (not for Gaussian)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function fnorm_lmn(a,it)
 implicit real(kind=8) (a-h,o-z)

 pi=acos(-1.d0)
 pi3=pi**3.d0

 select case(it)
   case(1)            ! 1S
     n1=3
     n2=3
     nf=1
   case(2:4)          ! 3P: x, y, z
     n1=7
     n2=5
     nf=1
   case(5:10)         ! 6D
     n1=11
     n2=7
     select case(it)
       case(5:7)        ! xx, yy, zz
         nf=9
       case(8:10)       ! xy, xz, yz
         nf=1
     end select
   case(11:20)        ! 10F
     n1=15
     n2=9
     select case(it)
       case(11:13)      ! xxx, yyy, zzz
         nf=225
       case(14:19)      ! xxy, xxz, yyz, xyy, xzz, yzz
         nf=9
       case(20)         ! xyz
         nf=1
     end select
   case(21:35)        ! 15G
     n1=19
     n2=11
     select case(it)
       case(21:23)      ! xxxx yyyy zzzz
         nf=11025
       case(24:29)      ! xxxy xxxz yyyx yyyz zzzx zzzy
         nf=225
       case(30:32)      ! xxyy xxzz yyzz
         nf=81
       case(33:35)      ! xxyz yyxz zzxy
         nf=9
     end select
!<<< Gaussian (subroutine pattml should also be modified)
!    select case(it)
!      case(21,25,35)               ! xxxx yyyy zzzz
!        nf=11025
!      case(22,24,26,29,33,34)      ! xxxy xxxz yyyx yyyz zzzx zzzy
!        nf=225
!      case(23,30,32)               ! xxyy xxzz yyzz
!        nf=81
!      case(27,28,31)               ! xxyz yyxz zzxy
!        nf=9
!    end select
!>>>
 end select

! Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
!   n1=3+4*(l+m+n)
!   n2=3+2*(l+m+n)
!   nf=[(2l-1)!!(2m-1)!!(2n-1)!!]^2
 f = (2.d0**dble(n1)) * (a**dble(n2)) / (pi3 * dble(nf))
 fnorm_lmn=sqrt(sqrt(f))

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write atoms, coordinates, and basis functions to the *.wfn (mode=0) or *.wfx (mode /= 0) file
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine writecnt(iwfn,mode,igto,imol,npg)
 implicit real(kind=8) (a-h,o-z)
 parameter(maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 character*1       :: al
 character*10      :: tmp

 rewind(igto)
 rewind(imol)
 ipt1=0
 ipt2=0

 read(imol,*)tmp,occ
 read(imol,*)tmp,eng
 100  read(igto,*,end=500)ic1
 200  read(igto,*)al,np
 if(al == 'E'.and.np == 0)goto 100
 do i=1,np
   read(igto,*)expgc(i),confc(i)
 end do
 select case(al)
   case('S')
     nfun=1
     it=0
   case('P')
     nfun=3
     it=1
   case('D')
     nfun=6
     it=4
   case('F')
     nfun=10
     it=10
   case('G')
     nfun=15
     it=20
 end select
 do i=1,nfun
   ipt1=ipt2+1
   ipt2=ipt1+np-1
   it=it+1
   expg(ipt1:ipt2)=expgc(1:np)
   conf(ipt1:ipt2)=confc(1:np)
   icnt(ipt1:ipt2)=ic1
   do j=ipt1,ipt2
     if(it >= 14.and.it <= 19)then
!      f: xyy, xxy, xxz, xzz, yzz, yyz (MOLDEN or Gaussian-out) -->
!         xxy, xxz, yyz, xyy, xzz, yzz (Gaussian-WFN or GAMESS-WFN)
       ityp(j)=iorder(it)
     else
       ityp(j)=it
     end if
   end do
!  read MO coeff. index
   read(imol,*)igc
   icmo(ipt1:ipt2)=igc
 end do
 goto 200

 500  continue

 if(mode == 0)then
!  wfn
   write(iwfn,"('CENTRE ASSIGNMENTS  ',20i3)")(icnt(i),i=1,npg)
   write(iwfn,"('TYPE ASSIGNMENTS    ',20i3)")(ityp(i),i=1,npg)
   write(iwfn,"('EXPONENTS ',5d14.7)")(expg(i),i=1,npg)
 else
!  wfx
   call wfxlab(iwfn,0,"Primitive Centers")
   write(iwfn,"(5i20)")(icnt(i),i=1,npg)
   call wfxlab(iwfn,1,"Primitive Centers")
   call wfxlab(iwfn,0,"Primitive Types")
   write(iwfn,"(5i20)")(ityp(i),i=1,npg)
   call wfxlab(iwfn,1,"Primitive Types")
   call wfxlab(iwfn,0,"Primitive Exponents")
   write(iwfn,"(5e21.12e3)")(expg(i),i=1,npg)
   call wfxlab(iwfn,1,"Primitive Exponents")
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! reorder f-functions from MOLDEN to WFN.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function iorder(n)
 implicit real(kind=8) (a-h,o-z)

 select case(n)
   case(14)
     iorder=17
   case(15)
     iorder=14
   case(16)
     iorder=15
   case(17)
     iorder=18
   case(18)
     iorder=19
   case(19)
     iorder=16
 end select

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read an <ENTER> to continue
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine xcontinue
 implicit real(kind=8) (a-h,o-z)

 write(*,"(/,' Press <ENTER> to continue')")
 read(*,*)

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! read an <ENTER> and stop
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine estop
 implicit real(kind=8) (a-h,o-z)

 write(*,"(//,' Press <ENTER> to exit',/)")
 read(*,*)

 stop

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! print spin of MO
! in ispn,    0: n.a.     1: alpha or alpha+beta    2: beta
! in iwfn,    1: alpha    2: beta    3: alpha+beta
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine writespn(iwfn,ispn,ifbeta,NMO)
 implicit real(kind=8) (a-h,o-z)
 parameter(ncol=40)
 dimension         :: is(ncol)

 rewind(ispn)
 write(iwfn,"(//,' $MOSPIN $END')")

 nline=NMO/ncol
 nlast=mod(NMO,ncol)

 do j=1,ncol
   is(j)=3
 end do
 do i=1,nline
   if(ifbeta == 1) read(ispn,"(i2)")(is(j),j=1,ncol)
   write(iwfn,"(40i2)")is(1:ncol)
 end do

 if(nlast > 0)then
   if(ifbeta == 1) read(ispn,"(i2)")(is(j),j=1,nlast)
   write(iwfn,"(40i2)")is(1:nlast)
 end if
 write(iwfn,"(/)")

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Mode = 0 : returns nuclear charge zchar for an element symbol "el"
!            iza is not used.
!   /= 0 : returns element symbol "el" for nuclear charge iza
!            zchar is not used.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine ElemZA(Mode,el,iza,zchar)
 implicit real(kind=8) (a-h,o-z)
 parameter (maxza=120)
 character*3       :: el,atomlib(maxza)
 data (atomlib(i),i=1,maxza) /  &
   'H  ','HE ','LI ','BE ','B  ','C  ','N  ','O  ','F  ','NE ',   'NA ','MG ','AL ','SI ','P  ','S  ','CL ','AR ','K  ','CA ',  &
   'SC ','TI ','V  ','CR ','MN ','FE ','CO ','NI ','CU ','ZN ',   'GA ','GE ','AS ','SE ','BR ','KR ','RB ','SR ','Y  ','ZR ',  &
   'NB ','MO ','TC ','RU ','RH ','PD ','AG ','CD ','IN ','SN ',   'SB ','TE ','I  ','XE ','CS ','BA ','LA ','CE ','PR ','ND ',  &
   'PM ','SM ','EU ','GD ','TB ','DY ','HO ','ER ','TM ','YB ',   'LU ','HF ','TA ','W  ','RE ','OS ','IR ','PT ','AU ','HG ',  &
   'TL ','PB ','BI ','PO ','AT ','RN ','FR ','RA ','AC ','TH ',   'PA ','U  ','NP ','PU ','AM ','CM ','BK ','CF ','ES ','FM ',  &
   'MD ','NO ','LR ','RF ','DB ','SG ','BH ','HS ','MT ','DS ',   'RG ','CN ','NH ','FL ','MC ','LV ','TS ','OG ','UUE','UBN'/
 save atomlib

 if (Mode == 0) then

   call charl2u(el)
   zchar = 0.d0
   do i=1,maxza
     if(index(el,atomlib(i)) /= 0)then
       zchar = dble(i)
       exit
     end if
   end do

 else

   el = "???"
   if(iza > 0 .and. iza <= maxza) el = adjustl(atomlib(iza))
   call charu2l(el(2:3))

 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write coordinates to WFN.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine writeatm(iwfn,iatm,icor,nat,iecp)
 implicit real(kind=8) (a-h,o-z)
 parameter (maxza=120,au2ang=0.529177249d0)
 character*3       :: am

 ncore=0
 rewind(icor)

 fc=1.d0
 rewind(iatm)
 read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
 if(iu == 0)fc=1.d0/au2ang

 do i=1,nat
   read(iatm,*)am,ia,iz,x,y,z
   if(iz > 0 .and. iz <= maxza) call ElemZA(1,am,iz,am)
   if(iecp > 0) read(icor,*)ia, ncore
   write(iwfn,100)am,i,i,x*fc,y*fc,z*fc,dble(iz-ncore)
 end do

 return
 100  format(2x,A3,i3,4x,'(CENTRE',i3,') ',3f12.8,'  CHARGE =',f5.1)
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! spherical MO --> Cartesian MO
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine sph2car(lq,fi,fo)
 implicit real(kind=8) (a-h,o-z)
! input & output MO factors
 dimension         :: fi(9),fo(15)
! map relationship between pure and Cartesian basis functions
 common/carsph/dmap(6,5),fmap(10,7),gmap(15,9)
 parameter(                   &
      c375 = 0.375d0,         &
      r3_4 = 0.8660254038d0,  &     ! sqrt(3/4)
      r5_4 = 1.1180339887d0,  &     ! sqrt(5/4)
      r6_5 = 1.0954451150d0,  &     ! sqrt(6/5)
      r9_7 = 1.1338934190d0,  &     ! sqrt(9/7)
     r10_7 = 1.1952286093d0,  &     ! sqrt(10/7)
      r5_8 = 0.7905694150d0,  &     ! sqrt(5/8)
      r9_8 = 1.0606601718d0,  &     ! sqrt(9/8)
     r5_16 = 0.5590169944d0,  &     ! sqrt(5/16)
    r27_28 = 0.9819805061d0,  &     ! sqrt(27/28)
    r35_64 = 0.7395099729d0,  &     ! sqrt(35/64)
   r27_560 = 0.2195775164d0,  &     ! sqrt(27/560)
      v3_4 =-0.8660254038d0,  &     !-sqrt(3/4)
      v5_4 =-1.1180339887d0,  &     !-sqrt(5/4)
      v3_8 =-0.6123724357d0,  &     !-sqrt(3/8)
      v5_8 =-0.7905694150d0,  &     !-sqrt(5/8)
      v9_8 =-1.0606601718d0,  &     !-sqrt(9/8)
     v5_16 =-0.5590169944d0,  &     !-sqrt(5/16)
    v27_16 =-1.2990381057d0,  &     !-sqrt(27/16)
     v9_20 =-0.6708203932d0,  &     !-sqrt(9/20)
     v5_28 =-0.4225771274d0,  &     !-sqrt(5/28)
    v27_28 =-0.9819805061d0,  &     !-sqrt(27/28)
    v27_35 =-0.8783100657d0,  &     !-sqrt(27/35)
     v3_40 =-0.2738612788d0,  &     !-sqrt(3/40)
     v9_56 =-0.4008918629d0,  &     !-sqrt(9/56)
    v45_56 =-0.8964214570d0)        !-sqrt(45/56)

! In pure basis functions, MOLDEN ordering is used.
! In Cartesian basis functions, MOLDEN order is used and will be re-ordered in subroutine writecnt.
! Ref. subroutine purdf in espot.f of MOLDEN 4.8. The result agrees with that of MOLPRO.

! 6D / 5D
 data ((dmap(j,i),j=1,6),i=1,5) /  &
!      xx      yy      zz      xy      xz      yz
   -0.5d0, -0.5d0,  1.0d0,  0.0d0,  0.0d0,  0.0d0,  &  ! d0  = zz-(xx+yy)/2
    0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0,  0.0d0,  &  ! d+1 = xz
    0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0,  &  ! d-1 = yz
     r3_4,   v3_4,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  &  ! d+2 = r3_4*(xx-yy)
    0.0d0,  0.0d0,  0.0d0,  1.0d0,  0.0d0,  0.0d0/     ! d-2 = xy

! 10F / 7F
 data ((fmap(j,i),j=1,10),i=1,7) /  &
!     xxx     yyy     zzz     xyy     xxy     xxz     xzz     yzz     yyz     xyz
    0.0d0,  0.0d0,  1.0d0,  0.0d0,  0.0d0,  v9_20,  0.0d0,  0.0d0,  v9_20,  0.0d0,  &  ! f0  = zzz-(xxz+yyz)*sqrt(9/20)
     v3_8,  0.0d0,  0.0d0,  v3_40,  0.0d0,  0.0d0,   r6_5,  0.0d0,  0.0d0,  0.0d0,  &  ! f+1 = -xxx*sqrt(3/8)-xyy*sqrt(3/40)+xzz*sqrt(6/5)
    0.0d0,   v3_8,  0.0d0,  0.0d0,  v3_40,  0.0d0,  0.0d0,   r6_5,  0.0d0,  0.0d0,  &  ! f-1 = -yyy*sqrt(3/8)-xxy*sqrt(3/40)+yzz*sqrt(6/5)
    0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r3_4,  0.0d0,  0.0d0,   v3_4,  0.0d0,  &  ! f+2 = (xxz-yyz)*sqrt(3/4)
    0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0,  &  ! f-2 = xyz
     r5_8,  0.0d0,  0.0d0,   v9_8,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  &  ! f+3 = xxx*sqrt(5/8)-xyy*sqrt(9/8)
    0.0d0,   v5_8,  0.0d0,  0.0d0,   r9_8,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0/     ! f-3 = yyy*sqrt(5/8)-xxy*sqrt(9/8)

! 15G / 9G
 data ((gmap(j,i),j=1,15),i=1,9) /  &
!    xxxx    yyyy    zzzz    xxxy    xxxz    yyyx    yyyz    zzzx    zzzy    xxyy    xxzz    yyzz    xxyz    yyxz    zzxy
     c375,   c375,  1.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,r27_560, v27_35, v27_35,  0.0d0,  0.0d0,  0.0d0,  &  ! g0  = (xxxx+yyyy)*c375+zzzz+xxyy*r27_560+(xxzz+yyzz)*v27_35
    0.0d0,  0.0d0,  0.0d0,  0.0d0, v45_56,  0.0d0,  0.0d0,  r10_7,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  v9_56,  0.0d0,  &  ! g+1 = xzzz*r10_7+xxxz*v45_56+yyxz*v9_56
    0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, v45_56,  0.0d0,  r10_7,  0.0d0,  0.0d0,  0.0d0,  v9_56,  0.0d0,  0.0d0,  &  ! g-1 = yzzz*r10_7+yyyz*v45_56+xxyz*v9_56
    v5_16,  r5_16,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, r27_28, v27_28,  0.0d0,  0.0d0,  0.0d0,  &  ! g+2 = -(xxxx-yyyy)*r5_16+(xxzz-yyzz)*r27_28
    0.0d0,  0.0d0,  0.0d0,  v5_28,  0.0d0,  v5_28,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r9_7,  &  ! g-2 = (xxxy+xyyy)*v5_28+zzxy*r9_7
    0.0d0,  0.0d0,  0.0d0,  0.0d0,   r5_8,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   v9_8,  0.0d0,  &  ! g+3 = xxxz*r5_8+yyxz*v9_8
    0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   v5_8,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r9_8,  0.0d0,  0.0d0,  &  ! g-3 = yyyz*v5_8+xxyz*r9_8
   r35_64, r35_64,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, v27_16,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  &  ! g+4 = (xxxx+yyyy)*r35_64+xxyy*v27_16
    0.0d0,  0.0d0,  0.0d0,   r5_4,  0.0d0,   v5_4,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0/     ! g-4 = (xxxy-xyyy)*r5_4

 fo=0.d0
 select case(lq)
   case(2)    ! D
     do j=1,5
       do i=1,6
         fo(i)=fo(i)+dmap(i,j)*fi(j)
       end do
     end do
   case(3)    ! F
     do j=1,7
       do i=1,10
         fo(i)=fo(i)+fmap(i,j)*fi(j)
       end do
     end do
   case(4)    ! G
     do j=1,9
       do i=1,15
         fo(i)=fo(i)+gmap(i,j)*fi(j)
       end do
     end do
   case default  ! S,P
     fo(1:9)=fi
     return
 end select

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write MO.s (spherical basis functions) to a temporary file.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine backupmols(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,iprog,th,tmp,ierr)
 implicit real(kind=8) (a-h,o-z)
 parameter(maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 character*100     :: tmp
 dimension         :: npure(5),puremo(9),ncart(5),cartmo(15),scal(9)
 data npure/1,3,5,7,9/,ncart/1,3,6,10,15/

! obtain scale factor for orca 2.7 (may be suitable for other versions)
!        class                           factor
!   1    s                             * 1.0
!        p
!        d
!        f(0,+1,-1,+2,-2)
!        g(0,+1,-1,+2,-2)
!   2    f(+3,-3)                      * -1.0
!        g(+3,-3,+4,-4)
! For low point group symmetries, the default MO factors by ORCA can not pass AIMALL's examination if there are f, g functions.
 scal=1.d0
 if(iprog == 1)scal(6:9)=-1.d0

 rewind(imol)
 rewind(ispn)
 rewind(imo0)

 sumocc=0.d0
 ierr=0
 ifspin=1    ! 0/1: without / with spin
 ifbeta=0    ! 0/1: without / with beta spin
 nmotot=0    ! total number of orbitals
 nmo=0       ! number of occupied orbitals
 ene=0.d0
 occ=0.d0
 Isp=0       ! 0 (unknown), 1 (alpha or alpha+beta), 2 (beta)

 200  read(imo0,"(100a)",end=500)tmp
 if(len_trim(tmp) == 0) goto 200
 call charl2u(tmp)
 if(index(tmp,'ENE') /= 0)then
   ene=0.d0
   is=index(tmp,'=')
!  in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
   if(index(tmp(is+1:),'***') == 0) then
     read(tmp(is+1:),*) ene
     ene = sign(min(abs(ene), 1.d6), ene)
   end if
 else if(index(tmp,'OCCUP') /= 0)then
   is=index(tmp,'=')
   read(tmp(is+1:),*) occ
   nmotot=nmotot+1
   if(abs(occ) > th) nmo=nmo+1
   sumocc=sumocc+occ
 else if(index(tmp,'SPIN') /= 0)then
   Isp = MOspin(tmp)
   ifspin=min(ifspin,Isp)
   ifbeta=max(ifbeta,Isp/2)
 else if(index(tmp,'SYM') /= 0)then
!  do nothing
 else
!  write occ, ene, and spin
   write(imol,"(A7,f20.8,/,A7,f20.8)")' OCCUP=',occ,' ENE=  ',ene
   if(abs(occ) > th) write(ispn,"(i2,2d20.7)")Isp,occ,ene
!  dump MO coefficients
   idxmo=0
   do i=1,nbs
     ltyp=ibstyp(i)
     nrd=npure(ltyp+1)
     nou=ncart(ltyp+1)
     do j=1,nrd
       if(i == 1 .and. j == 1)then
         read(tmp,*,err=300)it,puremo(j)
       else
         read(imo0,*,err=300)it,puremo(j)
       end if
       puremo(j)=puremo(j)*scal(j)
       cycle
!      find a star in the MO coefficients!
       300  ierr=1
       goto 500
     end do
!    There is a bug in NBO6: d(-1) and d(+1) should be exchanged!
     if(iprog == 9 .and. ltyp == 2) call swap(puremo(2),puremo(3))
     call sph2car(ltyp,puremo,cartmo)
     do j=1,nou
       idxmo=idxmo+1
       write(imol,"(i5,1x,d18.10)")idxmo,cartmo(j)
     end do
   end do
   ene=0.d0
   occ=0.d0
   Isp=0
 end if
 goto 200

 500  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! write MO.s (Cartesian basis functions) to a temporary file.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine backupmolc(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,ngc,th,tmp,ierr)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp

 rewind(imol)
 rewind(ispn)
 rewind(imo0)

 sumocc=0.d0
 ierr=0
 ifspin=1    ! 0/1: without / with spin
 ifbeta=0    ! 0/1: without / with beta spin
 nmotot=0    ! total number of orbitals
 nmo=0       ! number of occupied orbitals
 ene=0.d0
 occ=0.d0
 Isp=0       ! 0 (unknown), 1 (alpha or alpha+beta), 2 (beta)

 200  read(imo0,"(100a)",end=500)tmp
 if(len_trim(tmp) == 0) goto 200
 call charl2u(tmp)
 if(index(tmp,'ENE') /= 0)then
   ene=0.d0
   is=index(tmp,'=')
!  in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
   if(index(tmp(is+1:),'***') == 0) then
     read(tmp(is+1:),*) ene
     ene = sign(min(abs(ene), 1.d6), ene)
   end if
 else if(index(tmp,'OCCUP') /= 0)then
   is=index(tmp,'=')
   read(tmp(is+1:),*) occ
   write(*,*) "Occupation",occ
   nmotot=nmotot+1
   if(abs(occ) > th) nmo=nmo+1
   sumocc=sumocc+occ
 else if(index(tmp,'SPIN') /= 0)then
   Isp = MOspin(tmp)
   write(*,*) "Spin",Isp
   ifspin=min(ifspin,Isp)
   ifbeta=max(ifbeta,Isp/2)
 else if(index(tmp,'SYM') /= 0)then
!  do nothing
 else
!  write occ, ene, and spin
   write(imol,"(A7,f20.8,/,A7,f20.8)")' OCCUP=',occ,' ENE=  ',ene
   if(abs(occ) > th) write(ispn,"(i2,2d20.7)")Isp,occ,ene
!  dump MO coefficients
   do i=1,ngc
     if(i > 1) read(imo0,"(a100)")tmp
!    find a star in the MO coefficients!
     if(index(tmp,'*') /= 0)then
       ierr=1
       goto 500
     end if
     write(imol,"(a)")trim(tmp)
   end do
   ene=0.d0
   occ=0.d0
   Isp=0
 end if
 goto 200

 500  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! backup MO, and fill in missing zero coefficients if ishrt=1
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine fill0s(imo0,ncarmo,ishrt,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp

 imod=44
 rewind(imo0)
 rewind(imod)

 100  read(imod,"(100a)",end=9999)tmp
 call charl2u(tmp)
 if(index(tmp,'[MO]') /= 0)then
   if(ishrt == 0)then
     goto 200
   else
     nc = ncarmo
     goto 400
   end if
 end if
 goto 100

 200  read(imod,"(100a)",end=9999)tmp
 if(len_trim(tmp) == 0) goto 200
 if(index(tmp,'[') /= 0) goto 9999
 write(imo0,"(100a)")trim(tmp)
 goto 200

 400  read(imod,"(100a)",end=9990)tmp
 if(len_trim(tmp) == 0) goto 400
 if(index(tmp,'[') /= 0) goto 9990
 if(index(tmp,'=') /= 0)then
   if(nc < ncarmo .and. nc > 0)then
     do i=nc+1,ncarmo
       write(imo0,"(i5,f16.6)")i,0.d0
     end do
   end if
   nc = 0
   write(imo0,"(100a)")trim(tmp)
   goto 400
 end if

 nc = nc + 1
 read(tmp,*)idx
 if(nc < idx)then
   do i=nc,idx-1
     write(imo0,"(i5,f16.6)")i,0.d0
   end do
   nc = idx
 end if
 write(imo0,"(100a)")trim(tmp)
 goto 400

 9990  if(nc < ncarmo .and. nc > 0)then
   do i=nc+1,ncarmo
     write(imo0,"(i5,f16.6)")i,0.d0
   end do
 end if
 9999  write(imo0,*)
 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! get the number of contracted basis functions
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine readng(tmp,al,ng)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp
 character*2       :: al

 read(tmp,*)al,ng

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Write basis functions. S and P basis functions in SP are saved separately.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine truncate(imod,itmp,igtoin,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp
 character*2       :: al

! When there are huge lines to analyze, open/close is not stable.
! So I moved open and close on the top of truncate.
!
! open(itmp,file='temp123456789.tmp',status='new')

 call readng(tmp,al,ng)
 rewind(itmp)

 ng1=ng
 do i=1,ng
   if(al == 'SP')then
     read(imod,*)exp,fc1,fc2
   else
     read(imod,*)exp,fc1
     fc2=1.d0
   end if
   if(abs(fc1*fc2) > 1.d-8)then
     if(al == 'SP')then
       write(itmp,"(E20.10,2x,E20.10,2x,E20.10)")exp,fc1,fc2
     else
       write(itmp,"(E20.10,2x,E20.10)")exp,fc1
     end if
   else
     ng1=ng1-1
     cycle
   end if
 end do

 if(al == 'SP')then
   write(igtoin,*)"S ",ng1,"1.0"
 else
   write(igtoin,*)al,ng1,"1.0"
 end if

 rewind(itmp)
 do i=1,ng1
   read(itmp,*)exp,fc1
   write(igtoin,"(E20.10,2x,E20.10)")exp,fc1
 end do

! SP functions are saved separately
 if(al == 'SP')then
   write(igtoin,*)"P ",ng1,"1.0"
   rewind(itmp)
   do i=1,ng1
     read(itmp,*)exp,fc1,fc2
     write(igtoin,"(E20.10,2x,E20.10)")exp,fc2
   end do
 end if

! close(itmp,status='delete')

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! backup GTOs
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine backupgto(imod,igto,itmp,igtoin,igtold,nat,iprog,ifgto,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp
 character*2       :: al
 logical           :: find

 ispace=0
 ifirst=0
 ifgto=1

 open(itmp,file='temp123456789.tmp')
 open(igtoin,file='igt123456789.tmp')
 open(igtold,file='old123456789.tmp')
! step 1: backup original GTO
 rewind(imod)
 rewind(igtoin)

 100  read(imod,"(100a)",end=150)tmp
 call charl2u(tmp)
! [GTO]: MOLDEN file; [BASIS]: GABEDIT file
 find = index(tmp,'[GTO]') /= 0 .or. index(tmp,'[BASIS]') /= 0
 if(find)then    ! the first several blank lines are skipped
   do while(ifirst == 0)
     read(imod,"(100a)",end=500)tmp
     ifirst=len_trim(tmp)
   end do
   goto 201
 end if
 goto 100

 150  write(*,*)"### Wrong! [GTO] or [BASIS] can not be found!"
 ifgto=0
 close(igtoin,status='delete')
 return

 200  read(imod,"(100a)",end=500)tmp
 201  call charl2u(tmp)
 if(index(tmp,'[') /= 0) then
   if(ispace == 0)write(igtoin,"(' E 0')")    ! E = END
   goto 500
 else
   if(len_trim(tmp) > 0)then
     if(index(tmp,'S') /= 0.or.index(tmp,'P') /= 0.or.index(tmp,'D') /= 0.or.index(tmp,'F') /= 0.or.  &
        index(tmp,'G') /= 0.or.index(tmp,'H') /= 0)then
       call truncate(imod,itmp,igtoin,tmp)
     else
       write(igtoin,"(a)")trim(tmp)
     end if
     ispace=0
   else
     if(ispace == 0)then
       write(igtoin,"(' E 0')")    ! E = END
       ispace=1                    ! the second blank line is skipped
     end if
   end if
 end if
 goto 200

 500  continue

! step 2: re-normalize GTO and copy it to igtold because the GTO in the MOLDEN file may be unnormalized
 call bknorm(igtoin,igtold,iprog,ifgto)

! setp 3: reorder, and dump igtold to igto
 if(ifgto == 1) call dumpbs(igto,igtold,nat,ifgto,tmp)

 close(igtoin,status='delete')
 close(igtold,status='delete')
 close(itmp,status='delete')

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! reorder, and dump igtold to igto
!   NOTE: because of some uncertainties in the MOLDEN format, atoms in {Atoms} and [GTO] must be ordered ascendingly.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine dumpbs(igto,igtold,nat,ierr,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp

 rewind(igto)

 do i=1,nat
   call locatm(igtold,i,ierr,tmp)
   if(ierr == 0)goto 9999
   write(igto,"(i5,' 0')")i
   100  read(igtold,"(100a)",end=200)tmp
   if(tmp(1:1) == '&')goto 200
   write(igto,"(a)")trim(tmp)
   goto 100
   200  continue
 end do

 9999  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! locate atom-i in igtold
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine locatm(igtold,i,ierr,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp

 ierr=0
 rewind(igtold)
 100  read(igtold,"(100a)",end=1000)tmp
 if(tmp(1:1) /= '&')goto 100
 read(tmp(2:100),*)it
 if(it /= i)goto 100
 ierr=1

 return

 1000  write(*,"(/,' ### Wrong! No basis for atom ',i5,/)")i
 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! renormalize the basis set. it is important for some basis sets (eg. helium 6-31G)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine bknorm(igtoin,igtold,iprog,ierr)
 implicit real(kind=8) (a-h,o-z)
 parameter(maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 character*1       :: al

 rewind(igtold)
 rewind(igtoin)

 iat=0
 100  read(igtoin,*,end=500)ic1
 iat=iat+1
! check compatibility: because of some uncertainties in the MOLDEN
! format, the atomic indices must be 1,2,3,4,...
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! It's found that in Molden 5.0, if the ordering of GTO centers is,
! for example, 3,1,2, then the MO coefficients in [MO] are also in
! the same order 3,1,2.
! This means that the atoms in [Atoms] should be reordered according
! to the ordering in [GTO]. Example:
!
! < original MOLDEN file >
!
! [Atoms] Angs
! F     1    9    ...
! H     2    1    ...
! [GTO]
!   2 0
! ... (basis functions of H)
!   1 0
! ... (basis functions of F)
!
! < modified MOLDEN file >
!
! [Atoms] Angs
! H     1    1    ...
! F     2    9    ...
! [GTO]
!   1 0
! ... (basis functions of H)
!   2 0
! ... (basis functions of F)
!
! However in CFour's MOLDEN, the atomic numbers in [GTO] should be
! corrected.
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 if(iat /= ic1)then
   write(*,"(' Error: the atoms in [GTO] are not ordered ascendingly.',/,  &
     ' Please correct the MOLDEN file using ReOrdAtm in util by')")
   if(iprog == 2)then
     write(*,"(/,' roa.exe -m 1 < old_molden > new_molden')")
   else
     write(*,"(/,' roa.exe < old_molden > new_molden')")
   end if
   ierr=0
   goto 500
 end if

 write(igtold,"('&',i5,' 0')")ic1
 200  read(igtoin,*)al,np
 if(al == 'E'.and.np == 0)then
   write(igtold,"(1x,a1,1x,i1)")al,np
   goto 100
 else
   write(igtold,"(1x,a1,i4,' 1.0')")al,np
 end if

 do i=1,np
   read(igtoin,*)expgc(i),confc(i)
   cbs=1.d0
!  Orca, PSI4, NBO6: transform the basis set into input format
   if(iprog == 1 .or. iprog == 7 .or. iprog == 9) cbs=fnorm(expgc(i),al)
   confc(i)=confc(i)/cbs
 end do

! For uncontracted basis functions, the contraction coefficient can be renormalized to +1.0 or -1.0, depending on its sign.
! Do not change the sign!
 call renorm(al,expgc,confc,np)
 do i=1,np
   write(igtold,"(d20.10,2x,d20.10)")expgc(i),confc(i)
 end do
 goto 200

 500  continue

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! calculate the normalization factor for GTO(L)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function fnorm(ex,al)
 implicit real(kind=8) (a-h,o-z)
 character*1       :: al

 pi=acos(-1.d0)
 pi3=pi**3.d0

! unnormalize primitives
! Normal^4 = 2^n1 * a^n2 / (pi^3 * nf), where n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
 call power(al,n1,n2,nf)
 f = (2.d0**dble(n1)) * (ex**dble(n2)) / (pi3 * dble(nf))
 fnorm=sqrt(sqrt(f))

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! back up atoms and coordinates
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine backupatm(imod,iatm,ifatm,tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp
 character*3       :: element

 ifatm=1

 rewind(imod)
 rewind(iatm)

 100  read(imod,"(100a)",end=1010)tmp
 call charl2u(tmp)
 if(index(tmp,'[ATOMS]') /= 0) then
   if(index(tmp,'ANGS') /= 0)then
     iunit=0
   else if(index(tmp,'AU') /= 0)then
     iunit=1
   else
     iunit=2
   end if
   goto 200
 end if
 goto 100

 200  write(iatm,"(i1)")iunit
 201  read(imod,"(100a)",end=500)tmp
 call charl2u(tmp)
 if(index(tmp,'[') /= 0) then
   goto 500
 else
!  core electrons by ECP may be not inclued in iz (eg. in Molpro 2015), so iz should be obtained from atomic name
!  read: atomic_name number atomic_number x y z
   read(tmp,*,err=1020,end=1020)element,ia,iz0,x,y,z
!  eliminate non-letter characters for a special case, for example, O_1 (Dalton), C1 (Cadpac)
   call rmnumb(3,element)
   call ElemZA(0,element,za,za)
!  In the Molden program, atomic_name can be any characters and is omitted, so iz can be 0. In this case read iz from iz0.
   iz = nint(za)
   if(iz == 0) iz = iz0

   write(iatm,"(a3,1x,2i6,3f24.12)")element,ia,iz,x,y,z
 end if
 goto 201

 500  return

 1010  write(*,*)"*** Wrong! [ATOMS] can not be found!"
 ifatm=0
 return
 1020  write(*,*)"*** Error when reading the [ATOMS] section!"
 ifatm=0
 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! replace non-letter characters by space
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine rmnumb(N,cha)
 implicit real(kind=8) (a-h,o-z)
 character*(*)     :: cha

 do i=1,N
   if((ichar(cha(i:i)) >= 65) .and. (ichar(cha(i:i)) <= 90)) cycle     ! A-Z
   if((ichar(cha(i:i)) >= 97) .and. (ichar(cha(i:i)) <= 122)) cycle    ! a-z
   cha(i:i)=' '
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Routine to clear N characters
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine CClear(N,CA)
 implicit real(kind=8) (a-h,o-z)
 Character*(*)     :: CA

 Do I = 1,N
   CA(I:I) = " "
 end do

 Return
End

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! count the numbers of Cartesian and Spherical basis functions from GTO.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine npgau(igto,Ierr,ncar,nsph,MaxL,tmp)
 implicit real(kind=8) (a-h,o-z)
 parameter(maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
! Cartesian NC-/C-GTO; Spherical NC-/C-GTO
 dimension         :: ncar(2),nsph(2)
 character*100     :: tmp
 character*2       :: al

 ns=0
 np=0
 nd=0
 nf=0
 ng=0
 nsc=0
 npc=0
 ndc=0
 nfc=0
 ngc=0
 ibs=0
 MaxL=0
 Ierr=0

 rewind(igto)
 200  read(igto,"(100a)",end=500)tmp

 if(index(tmp,'S ') /= 0)then
   call readng(tmp,al,npg)
   ns=ns+npg
   nsc=nsc+1
   ibs=ibs+1
   if(ibs <= maxpgc)ibstyp(ibs)=0
 else if(index(tmp,'P ') /= 0)then
   call readng(tmp,al,npg)
   np=np+npg
   npc=npc+1
   ibs=ibs+1
   if(ibs <= maxpgc)ibstyp(ibs)=1
 else if(index(tmp,'D ') /= 0)then
   call readng(tmp,al,npg)
   nd=nd+npg
   ndc=ndc+1
   ibs=ibs+1
   if(ibs <= maxpgc)ibstyp(ibs)=2
 else if(index(tmp,'F ') /= 0)then
   call readng(tmp,al,npg)
   nf=nf+npg
   nfc=nfc+1
   ibs=ibs+1
   if(ibs <= maxpgc)ibstyp(ibs)=3
 else if(index(tmp,'G ') /= 0)then
   call readng(tmp,al,npg)
   ng=ng+npg
   ngc=ngc+1
   ibs=ibs+1
   if(ibs <= maxpgc)ibstyp(ibs)=4
 else if(index(tmp,'H ') /= 0)then
   Ierr=1
   goto 600
 end if

 goto 200

 500  ncar(1)=ns+np*3+nd*6+nf*10+ng*15
 ncar(2)=nsc+npc*3+ndc*6+nfc*10+ngc*15
 nsph(1)=ns+np*3+nd*5+nf*7+ng*9
 nsph(2)=nsc+npc*3+ndc*5+nfc*7+ngc*9
 nbs=ibs

! ncar(1)>=nsph(1)
! ncar(2)>=nsph(2)>=nbs
! so it's enough to check NCar only
 if(ncar(1) > maxpg)then
   write(*,"(//,1x,77('-'))")
   write(*,"(' Error: too many primitive Gaussian functions!')")
   write(*,"('  NCar(1) = ',i7,'   MaxPG = ',i7)")ncar(1),maxpg
   write(*,"(' Please increase MaxPG and try again.',/,1x,77('-'))")
   Ierr=2
 end if
 if(ncar(2) > maxpgc)then
   write(*,"(//,1x,77('-'))")
   write(*,"(' Error: too many contracted Gaussian functions!')")
   write(*,"('  NCar(2) = ',i7,'   MaxPGC = ',i7)")ncar(2),maxpgc
   write(*,"(' Please increase MaxPGC and try again.',/,1x,77('-'))")
   Ierr=2
 end if

! MaxL
 if(ng > 0)then
   MaxL=4
 else if(nf > 0)then
   MaxL=3
 else if(nd > 0)then
   MaxL=2
 else if(np > 0)then
   MaxL=1
 else
   MaxL=0
 end if

 600  continue

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! count the number of atoms.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine natom(iatm,nat,nchar,iunit,ierr)
 implicit real(kind=8) (a-h,o-z)
 character*10      :: tmp

 ierr=0

 iat=0
 nchar=0
 rewind(iatm)
 read(iatm,*)iunit

 200  read(iatm,*,end=500,err=300)tmp,nat,icha
 iat=iat+1
! check compatibility: because of some uncertainties in the MOLDEN format, the atomic indices must be 1,2,3,4,...
 if(iat /= nat)then
   write(*,"(' Error: atoms in [Atoms] are not ordered ascendingly.',/,  &
     ' Please correct the MOLDEN file using ReOrdAtm in util.')")
   ierr=1
   goto 500
 end if
 nchar=nchar+icha
 goto 200

! In the geometry optimization of deMon2k, the format is "atom, x, y, z"
 300  write(*,*)"*** The [Atoms] section is wrong!"
 write(*,*)"Please check your MOLDEN file carefully."
 ierr=1

 500  continue

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! tmp --> TMP
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine charl2u(tmp)
 implicit real(kind=8) (a-h,o-z)
 character*(*)     :: tmp
 character*1       :: L2U

 do i=1,len_trim(tmp)
   tmp(i:i)=L2U(tmp(i:i))
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! CHA --> cha
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine charu2l(cha)
 implicit real(kind=8) (a-h,o-z)
 character*(*)     :: cha
 character*1       :: U2L

 do i=1,len_trim(cha)
   cha(i:i)=U2L(cha(i:i))
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! l --> L
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function L2U(letter)
 implicit real(kind=8) (a-h,o-z)
 character*1       :: letter,L2U

 if((ichar(letter) >= 97).and.(ichar(letter) <= 122))then
   L2U=char(ichar(letter)-32)
 else
   L2U=letter
 endif

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! L --> l
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function U2L(letter)
 implicit real(kind=8) (a-h,o-z)
 character*1       :: letter,U2L

 if((ichar(letter) >= 65).and.(ichar(letter) <= 90))then
   U2L=char(ichar(letter)+32)
 else
   U2L=letter
 endif

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! length of a string without the first and last spaces.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nonspace(string)
 implicit real(kind=8) (a-h,o-z)
 character*(*)     :: string
 character*1       :: space

 space=' '
 length=LEN_TRIM(string)
 if(length == 0) then
  i=1
 else
  do i=1,length
    if(string(i:i) /= space) goto 20
  end do
 endif

 20  nonspace=i

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! lenchar: length of a string without tail spaces.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function lenchar(string)
 implicit real(kind=8) (a-h,o-z)
 character*(*)     :: string
 character*1       :: space

 space=' '
 i=len(string)

 do while(i > 0 .and. string(i:i) == space)
   i=i-1
 end do

 lenchar=i

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! trulen: true length of a string
! len1: pointor to the first non-space character
! len2: pointor to the last non-space character
! length: true length of a string without the initial and tail spaces
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine trulen(cha,len1,len2,length)
 implicit real(kind=8) (a-h,o-z)
 character*(*)     :: cha

 len1=nonspace(cha)
 len2=lenchar(cha)
 length=len2-len1+1

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! renormalize a contracted basis function
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine renorm(al,a,ci,ngauss)
 implicit real(kind=8) (a-h,o-z)
 parameter (tol=1.0d-10,maxpgc=10000)
 dimension         :: a(*),ci(*),c(maxpgc)
 character*1       :: al

 pi=acos(-1.d0)
 pi3=pi*pi*pi

! ngauss <= maxpgc has been checked in subroutine bknorm

! unnormalize primitives
! Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
!   n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
 call power(al,n1,n2,nf)
 fc = (2.d0**dble(n1)) / (pi3 * dble(nf))
 do i = 1,ngauss
   f = fc * (a(i)**dble(n2))
   f = sqrt(sqrt(f))
   c(i) = ci(i)*f
 end do

 fsum = 0.d0
 do i = 1,ngauss
   do j = 1,i
     a2 = (a(i)+a(j))/2.d0
     f = fc * (a2**dble(n2))
     f = sqrt(f)
     f = c(i)*c(j)/f
     if (i /= j) f = f*2.d0
     fsum = fsum+f
   end do
 end do

 if (fsum > tol) fsum = 1.d0/sqrt(fsum)
 do i = 1,ngauss
   ci(i) = ci(i) * fsum
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! get power(n1,n2,nf) for GTO(L) normalization
! n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine power(al,n1,n2,nf)
 implicit real(kind=8) (a-h,o-z)
 character*1       :: al

 n1=0
 n2=0
 nf=0
 select case(al)
   case('S')
     n1=3
     n2=3
     nf=1
   case('P')
     n1=7
     n2=5
     nf=1
   case('D')
     n1=11
     n2=7
     nf=9
   case('F')
     n1=15
     n2=9
     nf=225
   case('G')
     n1=19
     n2=11
     nf=11025
 end select

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! compute scaling factors for MO coefficients
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine moscale(igto,iprog,ncg)
 implicit real(kind=8) (a-h,o-z)
 parameter(maxpg=14000,maxpgc=10000)
 common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),cfmo(maxpg),cn(maxpg),scalmo(maxpgc),nbs,icnt(maxpg),  &
   ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
 dimension         :: itypc(maxpgc)
 character*1       :: al

! cfour, aces2, or molcas (cart.)
 if(iprog == 2 .or. iprog == 5 .or. iprog == 6)then
   goto 100
! turbomole
 else if(iprog == 3)then
   goto 200
! mrcc (cart.)
 else if(iprog == 8)then
   goto 300
 else
   goto 5000
 end if

 100  rewind(igto)
 ip1=0
 ip2=0
! Cartesian CGTO types of cfour, aces2, or molcas (cart.)
 110  read(igto,*,end=5000)
 120  read(igto,*)al,np
 if(al == 'E'.and.np == 0)goto 110
 do i=1,np
   read(igto,*)
 end do
 select case(al)
   case('S')
     ip1=ip2+1
     ip2=ip2+1
     itypc(ip1:ip2)=1
   case('P')
     ip1=ip2+1
     ip2=ip2+3
     itypc(ip1:ip2)=1
   case('D')
     ip1=ip2+1
     ip2=ip2+6
     itypc(ip1:(ip1+2))=2
     itypc((ip1+3):ip2)=1
   case('F')
     ip1=ip2+1
     ip2=ip2+10
     itypc(ip1:(ip1+2))=4
     itypc((ip1+3):(ip2-1))=2
     itypc(ip2:ip2)=1
   case('G')
     ip1=ip2+1
     ip2=ip2+15
     itypc(ip1:(ip1+2))=5
     itypc((ip1+3):(ip1+8))=4
     itypc((ip1+9):(ip1+11))=3
     itypc((ip2-2):ip2)=2
 end select
 goto 120

 200  rewind(igto)
 ip1=0
 ip2=0
! Cartesian CGTO types of turbomole
 210  read(igto,*,end=5000)
 220  read(igto,*)al,np
 if(al == 'E'.and.np == 0)goto 210
 do i=1,np
   read(igto,*)
 end do
 select case(al)
   case('S')
     ip1=ip2+1
     ip2=ip2+1
     itypc(ip1:ip2)=1
   case('P')
     ip1=ip2+1
     ip2=ip2+3
     itypc(ip1:ip2)=1
   case('D')
     ip1=ip2+1
     ip2=ip2+6
     itypc(ip1:ip2)=2
   case('F')
     ip1=ip2+1
     ip2=ip2+10
     itypc(ip1:ip2)=3
   case('G')
     ip1=ip2+1
     ip2=ip2+15
     itypc(ip1:ip2)=4
 end select
 goto 220

 300  rewind(igto)
 ip1=0
 ip2=0
! Cartesian CGTO types of mrcc
 310  read(igto,*,end=5000)
 320  read(igto,*)al,np
 if(al == 'E'.and.np == 0)goto 310
 do i=1,np
   read(igto,*)
 end do
 select case(al)
   case('S')
     ip1=ip2+1
     ip2=ip2+1
     itypc(ip1:ip2)=1
   case('P')
     ip1=ip2+1
     ip2=ip2+3
     itypc(ip1:ip2)=1
   case('D')
     ip1=ip2+1
     ip2=ip2+6
     itypc(ip1:(ip1+2))=1
     itypc((ip1+3):ip2)=2
   case('F')
     ip1=ip2+1
     ip2=ip2+10
     itypc(ip1:(ip1+2))=1
     itypc((ip1+3):(ip2-1))=3
     itypc(ip2:ip2)=4
   case('G')
     ip1=ip2+1
     ip2=ip2+15
     itypc(ip1:(ip1+2))=1
     itypc((ip1+3):(ip1+8))=5
     itypc((ip1+9):(ip1+11))=6
     itypc((ip2-2):ip2)=7
 end select
 goto 320

 5000  continue

 if(iprog == 2 .or. iprog == 5 .or. iprog == 6)then
!  cfour, aces2 (Cart.), or molcas (Cart.)
   do i=1,ncg
     scalmo(i)=obscalc4(itypc(i))
   end do
 else if(iprog == 3)then
!  turbomole (Cart.)
   do i=1,ncg
     scalmo(i)=obscaltm(itypc(i))
   end do
 else if(iprog == 8)then
!  mrcc (Cart.)
   do i=1,ncg
     scalmo(i)=obscalmr(itypc(i))
   end do
 else
!  default; orca (spher.); jaguar
   do i=1,ncg
     scalmo(i)=1.d0
   end do
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! obtain scale factor for mrcc (Cart.)
! class                                factor
! 1    s                             * 1.0
!      p(x,y,z)                      * 1.0
!      d(xx,yy,zz)
!      f(xxx,yyy,zzz)
!      g(x4,y4,z4)
! 2    d(xy,xz,yz)                   * 1/sqrt(3)
! 3    f(xyy,xzz,yxx,yzz,zxx,zyy)    * 1/sqrt(5)
! 4    f(xyz)                        * 1/sqrt(15)
! 5    g(x3y,x3z,y3x,y3z,z3x,z3y)    * 1/sqrt(7)
! 6    g(x2y2,x2z2,y2z2)             * sqrt(3/35)
! 7    g(x2yz,y2xz,z2xy)             * 1/sqrt(35)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function obscalmr(iclass)
 implicit real(kind=8) (a-h,o-z)

 select case(iclass)
   case(1)
     a=1.d0
   case(2)
     a=sqrt(1.d0/3.d0)
   case(3)
     a=sqrt(1.d0/5.d0)
   case(4)
     a=sqrt(1.d0/15.d0)
   case(5)
     a=sqrt(1.d0/7.d0)
   case(6)
     a=sqrt(3.d0/35.d0)
   case(7)
     a=sqrt(1.d0/35.d0)
 end select

 obscalmr=a

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! obtain scale factor for turbomole
! class                                factor
! 1    s                             * 1.0
!      p
! 2    d                             * sqrt(3)
! 3    f                             * sqrt(15)
! 4    g                             * sqrt(105)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function obscaltm(iclass)
 implicit real(kind=8) (a-h,o-z)

 select case(iclass)
   case(1)
     a=1.d0
   case(2)
     a=sqrt(3.d0)
   case(3)
     a=sqrt(15.d0)
   case(4)
     a=sqrt(105.d0)
 end select

 obscaltm=a

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! obtain scale factor for cfour
! class                                factor
! 1    s                             * 1.0
!      p(x,y,z)
!      d(xy,xz,yz)
!      f(xyz)
! 2    d(xx,yy,zz)                   * sqrt(3)
!      f(xyy,xzz,yxx,yzz,zxx,zyy)
!      g(x2yz,y2xz,z2xy)
! 3    g(x2y2,x2z2,y2z2)             * 3.0
! 4    f(xxx,yyy,zzz)                * sqrt(15)
!      g(x3y,x3z,y3x,y3z,z3x,z3y)
! 5    g(x4,y4,z4)                   * sqrt(105)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function obscalc4(iclass)
 implicit real(kind=8) (a-h,o-z)

 select case(iclass)
   case(1)
     a=1.d0
   case(2)
     a=sqrt(3.d0)
   case(3)
     a=3.d0
   case(4)
     a=sqrt(15.d0)
   case(5)
     a=sqrt(105.d0)
 end select

 obscalc4=a

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! calculate the overlap matrix element
! s = <itype1, a1, r1 | itype2, a2, r2>
!   = <l1, m1, n1, a1, r1 | l2, m2, n2, a2, r2>
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine overlap(s,itype1,a1,r1,itype2,a2,r2,MaxL,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: r1(3),r2(3),p(3),dgn(0:MaxL),pan(0:MaxL,3),pbn(0:MaxL,3)
 data one/1.d0/
 save one

 pi=acos(-one)

! production of the normalization factors
 s=fnorm_lmn(a1,itype1)*fnorm_lmn(a2,itype2)

! gamma = as + bs and (2*gamma)^-n
 g=a1+a2
 dg=g+g
 dgn(0)=one
 do i=1,MaxL
   dgn(i)=dgn(i-1)/dg
 end do

 tmp1=dist(r1,r2)
 s=s*exp(-a1*a2*tmp1*tmp1/g)
 tmp1=sqrt(pi/g)
 s=s*tmp1*tmp1*tmp1

! P point
 p(1)=(a1*r1(1)+a2*r2(1))/g
 p(2)=(a1*r1(2)+a2*r2(2))/g
 p(3)=(a1*r1(3)+a2*r2(3))/g

! pa^n and pb^n
 do j=1,3
   pan(0,j)=one
   pbn(0,j)=one
 end do
 if(MaxL > 0)then
   do j=1,3
     pan(1,j)=p(j)-r1(j)
     pbn(1,j)=p(j)-r2(j)
   end do
   do i=2,MaxL
     do j=1,3
       pan(i,j)=pan(i-1,j)*pan(1,j)
       pbn(i,j)=pbn(i-1,j)*pbn(1,j)
     end do
   end do
 end if

 call pattwf(itype1,l1,m1,n1,info)
   if(info /= 0) goto 9000
 call pattwf(itype2,l2,m2,n2,info)
   if(info /= 0) goto 9000

 call integ(sx,MaxL,l1,l2,dgn,pan(0,1),pbn(0,1))
 call integ(sy,MaxL,m1,m2,dgn,pan(0,2),pbn(0,2))
 call integ(sz,MaxL,n1,n2,dgn,pan(0,3),pbn(0,3))
 s=s*sx*sy*sz

 9000  return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! calculate the integral Ix, Iy, or Iz
!   (l1+l2)/2
! I = sum [fcoef * (2i-1)!! / (2g)^i]
!     i=0
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine integ(s,MaxL,l1,l2,dgn,pan,pbn)
 implicit real(kind=8) (a-h,o-z)
! Tlm1ff = (2N -1)!!, N=0~5; (2g)^-i; pa^n; pb^n
 dimension         :: Tlm1ff(0:5),dgn(0:MaxL),pan(0:MaxL),pbn(0:MaxL)
 data Tlm1ff/1.D0, 1.D0, 3.D0, 15.D0, 105.D0, 945.D0/
 save Tlm1ff

 s=0.d0
 do i=0,(l1+l2)/2
   call fcoef(tmp,MaxL,i+i,l1,l2,pan,pbn)
   tmp=tmp*Tlm1ff(i)*dgn(i)
   s=s+tmp
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! calculate the coefficients
!           l1   l2
! fcoef =  sum  sum [clm(l1,k1) * clm(l2,k2) * a^(l1-k1) * b^(l2-k2)]
!         k1=0 k2=0
!          k1+k2=i
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine fcoef(fc,MaxL,i,l1,l2,pan,pbn)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: pan(0:MaxL),pbn(0:MaxL)

 fc=0.d0
 do k1=0,l1
   k2=i-k1
   if(k2 < 0 .or. k2 > l2) cycle
   fc = fc + pan(l1-k1) * pbn(l2-k2) * clm(l1,k1) * clm(l2,k2)
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! clm = l! / (m! * (l-m)!)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function clm(l,m)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: factorial(0:5)
 data factorial/1.D0,1.D0,2.D0,6.D0,24.D0,120.D0/
 save factorial

 clm=factorial(l)/(factorial(m)*factorial(l-m))

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! distance between two points
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function dist(p1,p2)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: p1(3),p2(3)

 dist=0.d0
 do i=1,3
   dist=dist+(p1(i)-p2(i))*(p1(i)-p2(i))
 end do
 dist=sqrt(dist)

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! vout = c * vin
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine ascale(N,c,vin,vout)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: vin(*),vout(*)

 do i=1,N
   vout(i)=c*vin(i)
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Routine to clear N elements in array A.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine AClear(N,A)
 implicit real(kind=8) (a-h,o-z)
 parameter(Zero=0.0d0)
 dimension         :: A(*)

 Do I = 1,N
   A(I) = Zero
 end do

 Return
End

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Obtain the xyz pattern for a given Cartesian type number. It is used in MOLDEN.
! Note: the ordering 14-19 of F functions is different from the one in subroutine pattwf.
! 1  S     | 11 FXXX  | 21 GXXXX | 31 GXXZZ |
! 2  PX    | 12 FYYY  | 22 GYYYY | 32 GYYZZ |
! 3  PY    | 13 FZZZ  | 23 GZZZZ | 33 GXXYZ |
! 4  PZ    | 14 FXYY  | 24 GXXXY | 34 GXYYZ |
! 5  DXX   | 15 FXXY  | 25 GXXXZ | 35 GXYZZ |
! 6  DYY   | 16 FXXZ  | 26 GXYYY |
! 7  DZZ   | 17 FXZZ  | 27 GYYYZ |
! 8  DXY   | 18 FYZZ  | 28 GXZZZ |
! 9  DXZ   | 19 FYYZ  | 29 GYZZZ |
! 10 DYZ   | 20 FXYZ  | 30 GXXYY |
!
! Ordering of G functions in Gaussian. For debug only.
! 21 GZZZZ | 31 GXXYZ |
! 22 GYZZZ | 32 GXXYY |
! 23 GYYZZ | 33 GXXXZ |
! 24 GYYYZ | 34 GXXXY |
! 25 GYYYY | 35 GXXXX |
! 26 GXZZZ |
! 27 GXYZZ |
! 28 GXYYZ |
! 29 GXYYY |
! 30 GXXZZ |
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine pattml(itype,l,m,n,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: PATDAT(3,35)
 data PATDAT/  &
!              1          2          3          4          5              6          7          8          9         10
         0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,       0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,  &
!             11         12         13         14         15             16         17         18         19         20
         3, 0, 0,   0, 3, 0,   0, 0, 3,   1, 2, 0,   2, 1, 0,       2, 0, 1,   1, 0, 2,   0, 1, 2,   0, 2, 1,   1, 1, 1,  &
!             21         22         23         24         25             26         27         28         29         30
         4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,       1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,  &
!             31         32         33         34         35
         2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2/
!<<< Gaussian (see also function fnorm_lmn)
!             21         22         23         24         25             26         27         28         29         30
!        0, 0, 4,   0, 1, 3,   0, 2, 2,   0, 3, 1,   0, 4, 0,       1, 0, 3,   1, 1, 2,   1, 2, 1,   1, 3, 0,   2, 0, 2,  &
!             31         32         33         34         35
!        2, 1, 1,   2, 2, 0,   3, 0, 1,   3, 1, 0,   4, 0, 0/
!>>>
 save PATDAT

 info = 0
 if(itype < 1 .or. itype > 35)then
   info = 1
   write(*,"(/,' ### Wrong!',' The Cartesian type number is out of range:',i3)")itype
   return
 end if

 l=PATDAT(1,itype)
 m=PATDAT(2,itype)
 n=PATDAT(3,itype)

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! Obtain the xyz pattern for a given Cartesian type number. It is
! used in WFN and WFX.
! 1  S     | 11 FXXX  | 21 GXXXX | 31 GXXZZ |
! 2  PX    | 12 FYYY  | 22 GYYYY | 32 GYYZZ |
! 3  PY    | 13 FZZZ  | 23 GZZZZ | 33 GXXYZ |
! 4  PZ    | 14 FXXY  | 24 GXXXY | 34 GXYYZ |
! 5  DXX   | 15 FXXZ  | 25 GXXXZ | 35 GXYZZ |
! 6  DYY   | 16 FYYZ  | 26 GXYYY |
! 7  DZZ   | 17 FXYY  | 27 GYYYZ |
! 8  DXY   | 18 FXZZ  | 28 GXZZZ |
! 9  DXZ   | 19 FYZZ  | 29 GYZZZ |
! 10 DYZ   | 20 FXYZ  | 30 GXXYY |
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine pattwf(itype,l,m,n,info)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: PATDAT(3,35)
 data PATDAT/  &
!              1          2          3          4          5              6          7          8          9         10
         0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,       0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,  &
!             11         12         13         14         15             16         17         18         19         20
         3, 0, 0,   0, 3, 0,   0, 0, 3,   2, 1, 0,   2, 0, 1,       0, 2, 1,   1, 2, 0,   1, 0, 2,   0, 1, 2,   1, 1, 1,  &
!             21         22         23         24         25             26         27         28         29         30
         4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,       1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,  &
!             31         32         33         34         35
         2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2/
 save PATDAT

 info = 0
 if(itype < 1 .or. itype > 35)then
   info = 1
   write(*,"(/,' ### Wrong!',' The Cartesian type number is out of range:',i3)")itype
   return
 end if

 l=PATDAT(1,itype)
 m=PATDAT(2,itype)
 n=PATDAT(3,itype)

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! B(*) = A(*)
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine ACopy(N,A,B)
 implicit real(kind=8) (a-h,o-z)
 dimension         :: A(*),B(*)

 Do I = 1,N
   B(I) = A(I)
 end do

 Return
End

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! swap a and b
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine swap(a,b)
 implicit real(kind=8) (a-h,o-z)

 scr=a
 a=b
 b=scr

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! C = C + A * B, where A and B are symmetric in L.T. and C is in Sq. The following relationship is adopted:
! M_sq(j,i) = M_lt(j+(i-1)*i/2) if j <= i
!           = M_lt(i+(j-1)*j/2) if j > i
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine LTxLT(N,A,B,C)
 implicit real(kind=8) (a-h,o-z)
 parameter(half=0.5d0)
 dimension         :: A(*),B(*),C(N,N)

 do i = 1,N
   i0 = i*(i-1)/2
   X = A(i+i0)
   do j = 1,i
     C(j,i) = X * B(j+i0)
   end do
   do j = i + 1,N
     j0 = j*(j-1)/2
     C(j,i) = X * B(i+j0)
   end do
   do j = 1,i - 1
     j0 = j*(j-1)/2
     X = A(j+i0)
     do k = 1,j
       C(k,i) = C(k,i) + X * B(k+j0)
     end do
     do k = j+1,N
       k0 = k*(k-1)/2
       C(k,i) = C(k,i) + X * B(j+k0)
     end do
   end do
   do j = i + 1,N
     j0 = j*(j-1)/2
     X = A(i+j0)
     do k = 1,j
       C(k,i) = C(k,i) + X * B(k+j0)
     end do
     do k = j+1,N
       k0 = k*(k-1)/2
       C(k,i) = C(k,i) + X * B(j+k0)
     end do
   end do
 end do

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! spin of MO:
!   0: unknown
!   1: Alpha, or Alpha and Beta
!   2: Beta
! NOTE: tmp must be in upper case and contains 'SPIN'
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function MOspin(tmp)
 implicit real(kind=8) (a-h,o-z)
 character*100     :: tmp

 if(index(tmp,'ALPHA') /= 0)then
   MOspin=1
 else if(index(tmp,'BETA') /= 0)then
   MOspin=2
 else
   MOspin=0
 end if

 return
end

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!
! This subroutine is taken from BLAS (version 3.4.0, November 2011).
! BLAS is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.
!
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Subroutine DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
! Scalar Arguments ..
 DOUBLE PRECISION ALPHA,BETA
 INTEGER K,LDA,LDB,LDC,M,N
 CHARACTER TRANSA,TRANSB
! Array Arguments ..
 DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)
! Intrinsic Functions ..
 INTRINSIC MAX
! Local Scalars ..
 DOUBLE PRECISION TEMP
 INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB
 LOGICAL NOTA,NOTB
! Parameters ..
 DOUBLE PRECISION ONE,ZERO
 PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)

! Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not transposed and set  NROWA, NCOLA and  NROWB
!  as the number of rows and  columns of  A  and the  number of  rows  of  B  respectively.
 NOTA = TRANSA == 'N'
 NOTB = TRANSB == 'N'
 IF (NOTA) THEN
     NROWA = M
     NCOLA = K
 ELSE
     NROWA = K
     NCOLA = M
 END IF
 IF (NOTB) THEN
     NROWB = K
 ELSE
     NROWB = N
 END IF

! Test the input parameters.
 INFO = 0
 IF ((.NOT.NOTA) .AND. (.NOT.(TRANSA == 'C')) .AND. (.NOT.(TRANSA == 'T'))) THEN
     INFO = 1
 ELSE IF ((.NOT.NOTB) .AND. (.NOT.(TRANSB == 'C')) .AND. (.NOT.(TRANSB == 'T'))) THEN
     INFO = 2
 ELSE IF (M < 0) THEN
     INFO = 3
 ELSE IF (N < 0) THEN
     INFO = 4
 ELSE IF (K < 0) THEN
     INFO = 5
 ELSE IF (LDA < MAX(1,NROWA)) THEN
     INFO = 8
 ELSE IF (LDB < MAX(1,NROWB)) THEN
     INFO = 10
 ELSE IF (LDC < MAX(1,M)) THEN
     INFO = 13
 END IF
 IF (INFO /= 0) THEN
     WRITE( *, FMT = 9999 ) INFO
     call estop
 END IF

! Quick return if possible.
 IF ((M == 0) .OR. (N == 0) .OR. (((ALPHA == ZERO).OR. (K == 0)).AND. (BETA == ONE))) RETURN
! And if  alpha == zero.
 IF (ALPHA == ZERO) THEN
     IF (BETA == ZERO) THEN
         DO J = 1,N
             DO I = 1,M
                 C(I,J) = ZERO
             end do
         end do
     ELSE
         DO J = 1,N
             DO I = 1,M
                 C(I,J) = BETA*C(I,J)
             end do
         end do
     END IF
     RETURN
 END IF

! Start the operations.
 IF (NOTB) THEN
     IF (NOTA) THEN

!        Form  C := alpha*A*B + beta*C.
         DO J = 1,N
             IF (BETA == ZERO) THEN
                 DO I = 1,M
                     C(I,J) = ZERO
                 end do
             ELSE IF (BETA /= ONE) THEN
                 DO I = 1,M
                     C(I,J) = BETA*C(I,J)
                 end do
             END IF
             DO L = 1,K
                 IF (B(L,J) /= ZERO) THEN
                     TEMP = ALPHA*B(L,J)
                     DO I = 1,M
                         C(I,J) = C(I,J) + TEMP*A(I,L)
                     end do
                 END IF
             end do
         end do
     ELSE

!        Form  C := alpha*A**T*B + beta*C
         DO J = 1,N
             DO I = 1,M
                 TEMP = ZERO
                 DO L = 1,K
                     TEMP = TEMP + A(L,I)*B(L,J)
                 end do
                 IF (BETA == ZERO) THEN
                     C(I,J) = ALPHA*TEMP
                 ELSE
                     C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                 END IF
             end do
         end do
     END IF
 ELSE
     IF (NOTA) THEN
!        Form  C := alpha*A*B**T + beta*C
         DO J = 1,N
             IF (BETA == ZERO) THEN
                 DO I = 1,M
                     C(I,J) = ZERO
                 end do
             ELSE IF (BETA /= ONE) THEN
                 DO I = 1,M
                     C(I,J) = BETA*C(I,J)
                 end do
             END IF
             DO L = 1,K
                 IF (B(J,L) /= ZERO) THEN
                     TEMP = ALPHA*B(J,L)
                     DO I = 1,M
                         C(I,J) = C(I,J) + TEMP*A(I,L)
                     end do
                 END IF
             end do
         end do
     ELSE
!        Form  C := alpha*A**T*B**T + beta*C
         DO J = 1,N
             DO I = 1,M
                 TEMP = ZERO
                 DO L = 1,K
                     TEMP = TEMP + A(L,I)*B(J,L)
                 end do
                 IF (BETA == ZERO) THEN
                     C(I,J) = ALPHA*TEMP
                 ELSE
                     C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                 END IF
             end do
         end do
     END IF
 END IF

 RETURN
 9999 FORMAT( ' ** On entry to DGEMM parameter number ', I2, ' had an illegal value' )
END

!--- END
